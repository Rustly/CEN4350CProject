import { Carousel } from './carousel';
import { CarouselService } from './carousel.service';
export declare class Slider {
    private readonly carousel;
    private readonly responsive;
    private readonly slideToScroll;
    private readonly LIMIT_AUTO_SLIDE;
    private readonly strechingLimit;
    private readonly autoSlide;
    private readonly animationTimingFn;
    private readonly animationTimingMs;
    private readonly MAX_DOM_SIZE;
    private readonly enableMouseDrag;
    private readonly enableTouch;
    private readonly infinite;
    private carouselService;
    dragging: boolean;
    currentSlide: number;
    lastWindow: number;
    currentTranslation: number;
    previousTranslation: number;
    direction: 'right' | 'left';
    startX: number;
    previousX: number;
    currentX: number;
    positionChange: number;
    prevLimit: number;
    nextLimit: number;
    slidesContainer: HTMLDivElement;
    arrayOfSlides: HTMLDivElement[];
    totalAmountOfSlides: number;
    initialFullWidth: number;
    lastWindowTranslation: number;
    totalSlides: number;
    DOMLimitReached: boolean;
    visibleOffsetCardNotResponsive: number;
    invisibleOffsetCardNotResponsive: number;
    accumulatedSlide: number;
    currentCarouselID: number;
    constructor(carousel: Carousel, responsive: boolean, slideToScroll: number, LIMIT_AUTO_SLIDE: number, strechingLimit: number, autoSlide: boolean, animationTimingFn: string, animationTimingMs: number, MAX_DOM_SIZE: number, enableMouseDrag: boolean, enableTouch: boolean, infinite: boolean, carouselService: CarouselService);
    initProperties(): void;
    /**
     * Update properties of the slider
     * Fired at start and at resizing.
     */
    updateProperties(): void;
    updateNotResponsive(): void;
    /**
     * Add slides to the right at start
     * If only one window (number of dots === 1) and not responsive mode, there is possibly space at start for slides to the right (even though this configuration does not make a lot of sense)
     */
    addSlidesToRightAtStart(): void;
    /**
     * Fired at drag start
     * Instantiate property of the starting drag point on the X axis. Used to compute the translation.
     * Disabling the transition while applying the transformation because of the attached animation.
     */
    dragStart(event: MouseEvent | TouchEvent): void;
    /**
     * Fired at drag end
     * If not infinite mode and limits reached (start or end), put back to the current slide. Updates previous translation.
     */
    dragStop(event: MouseEvent | TouchEvent): void;
    currentEventIsDisabled(event: MouseEvent | TouchEvent): boolean;
    /**
     * Update the direction
     * Do not update the direction in case of the same previous position.
     */
    setDirection(): void;
    /**
     * Fired at dragging
     * Compute the translation, change the slide number, update the direction.
     */
    dragMove(event: MouseEvent | TouchEvent): void;
    strechingEffect(): boolean;
    /**
     * Modify current slide
     * Take into account finite and infinite mode and auto slide.
     * Responsible for changing slide number and updating the limits.
     * If createSlidesInfiniteModeIfLimitsReached() doesn't take action, slide change according to previous computed limits.
     * In finite mode, if all slides visible on one window or end of carousel, early return to not trigger Rxjs Subject.
     */
    modifyCurrentSlide(): void;
    /**
     * Handle slide creation in infinite mode if limits reached
     * Mouse or touch drag.
     */
    createSlidesInfiniteModeIfLimits(): boolean;
    /**
     * Auto slide card if option enabled, applied on both directions.
     * Prevents auto slide on limits in finite mode (if streching < limit auto slide).
     * If only one slide is displayed (slideToShow === 1), the width of the slide corresponds to the window's width (a dot). Hence, taking the min between the two.
     * In non responsive and non infinite, there is possibly an offset of the current limit.
     */
    autoSlider(): void;
    /**
     * Append or prepend new slides according to the direction
     * If new slides prepended, update the translation to the correct place (appending new slides do not change the translation).
     * Limit DOM growth or update last window translation if applicable.
     */
    appendOrPrependNElements(): void;
    /**
     * Limit DOM growth
     * Reset the view accordingly.
     */
    limitDOMGrowth(): void;
    /**
     * Reset the view in a movement to the left
     * New slides added to the left, so the view has to be updated accordingly.
     * If the carousel is moved with the mouse | touch event (dragging is true), the offset should be equal to a full carousel width. Otherwise (with the buttons), the computed translation should be taken into account.
     * Side comment: the view does not have to be updated for slides added to the right, since relative order does not change.
     * getBoundingClientRect triggers reflow of the element.
     */
    resetViewLeftDirection(): void;
    /**
     * Reset the view in a movement to the right
     * First set of slides have been deleted, so the translation has to be updated accordingly.
     * currentTranslation is a negative number so it will be decreased by a set of slides.
     * getBoundingClientRect triggers reflow of the element.
     */
    resetViewRightDirection(): void;
    /**
     * Update the last window translation
     * Useful to get the max translation at the end of the slides.
     * In not responsive mode, there is possibly a not fully displayed card (card offset).
     */
    updateLastWindowTranslation(): void;
    addSlidesToTheLeft(): void;
    addSlidesToTheRight(): void;
    /**
     * Decrease limit (movement to the left)
     * In infinite mode, take full width of a set if on the first slide as new slides are created to the left (a whole set offset).
     * Exception: if not responsive (card offset) and finite carousel, the next limit is at the maximum (the end of the carousel)
     */
    decreaseLimits(slidesCreatedOnTheLeft?: boolean): void;
    /**
     * Increase limit on basis of previous computed limits (movement to the right)
     * Schema: || previous | current || next
     * Exception: if not responsive (card offset) and finite carousel, the next limit is at the maximum (the end of the carousel)
     */
    increaseLimits(): void;
    /**
     * Change prev and next limit on basis of the provided slide number
     * Prev and next limit are always calculated as the following:
     * || <= prev | current || <= next
     */
    changePrevAndNextLimits(slideNumber: number): void;
    /**
     * Previous button navigation
     */
    prev(): void;
    /**
     * Next button navigation
     */
    next(): void;
    /**
     * Buttons navigation in infinite mode
     * Create new slide if limits reached (start or end). Update slide, limits and apply transformation accordingly.
     */
    handleBtnInfinite(step: number): void;
    /**
     * Navigation with bullet points
     * Update values accordingly.
     */
    goTo(bullet: number): void;
    /**
     * Bullets navigation
     * Create new slides if exceeding end of carousel.
     */
    navInfiniteBullets(bullet: number): void;
    /**
     * Responsible for changing slide number in finite and infinite mode
     * Exception: if only one window (numberDots === 1), update the accumulatedSlide to let the transformation occurs, but currentSlide should stay at 0.
     */
    changeSlideNumber(step: number): void;
    infiniteChangeSlideNumber(step: number): void;
    finiteChangeSlideNumber(step: number): void;
    /**
     * Compute transformation that will be applied on basis of the provided slide number
     * Exception: if not responsive (card offset) and finite carousel, the next limit is the end of the carousel
     */
    computeTransformation(slide: number): void;
    applyTransformation(transformation: number): void;
    /**
     * Trigger drag stop
     * If client leaves the page (navigating to another tab) and comes back, stop the dragging.
     * Correct Typescript typing not possible?
     */
    unActiveTab(event: any): void;
}
