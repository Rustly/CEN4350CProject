import * as i0 from '@angular/core';
import { Injectable, PLATFORM_ID, Component, ChangeDetectionStrategy, Inject, Input, NgModule } from '@angular/core';
import { Subject, fromEvent } from 'rxjs';
import * as i2 from '@angular/common';
import { isPlatformBrowser, CommonModule } from '@angular/common';

class Carousel {
    constructor(carousel, maxWidthCarousel, slideToShow, slideWidth, slideMaxWidth, gap, responsive, loop) {
        this.carousel = carousel;
        this.maxWidthCarousel = maxWidthCarousel;
        this.slideToShow = slideToShow;
        this.slideWidth = slideWidth;
        this.slideMaxWidth = slideMaxWidth;
        this.gap = gap;
        this.responsive = responsive;
        this.loop = loop;
        this.arrayNumberDots = [];
        this.maxScrollableContent = 0;
        this.totalSlides = 0;
        this.initialSlideToShow = 1;
        this.paddingCarousel = 0;
        this.arrayOfSlides = [];
        this.init();
    }
    init() {
        this.paddingCarousel = this.getPaddingCarousel();
        this.initialSlideToShow = this.slideToShow;
        this.slidesContainer = this.selectSlidesContainer();
        this.slides = this.selectSlides();
        this.arrayOfSlides = this.slidesToArray();
        this.totalSlides = this.slides.length;
        this.originalSlideWidth = this.slideWidth;
        this.setWidthSlides();
        this.setMaxWidthCarousel();
        this.updateProperties();
        this.slidesContainer.style.gap = `${this.gap}px`;
        this.setDraggableImgToFalse();
    }
    /**
     * Set the slide width and max width
     * NB: In responsive mode, width is automatically adapted through the setAutoColumnSlideContainer() method.
     *
     */
    setWidthSlides() {
        for (const slide of this.slides) {
            slide.style.maxWidth = `${this.slideMaxWidth}px`;
            slide.style.width = '100%';
            slide.style.userSelect = 'none';
            if (!this.responsive) {
                slide.style.width = `${this.slideWidth}px`;
            }
        }
    }
    /**
     * Update carousel properties
     * Occurs at start and at resizing.
     */
    updateProperties() {
        this.carouselWidth = this.carousel.clientWidth;
        if (this.responsive) {
            this.updateSlideToShowResponsive();
            this.setAutoColumnSlideContainer();
        }
        else {
            this.updateSlideToShowNotResponsive();
        }
        this.numberDots = this.setNumberDots();
        this.arrayNumberDots = [...Array(this.numberDots).keys()];
        this.slideWidthWithGap = this.slideWidth + this.gap;
        this.setWidthSlideContainer();
        this.maxScrollableContent = this.getMaxScroll();
    }
    /**
     * Update slide to show (responsive mode)
     * Computes the number of slide fitting
     */
    updateSlideToShowResponsive() {
        const slideWidthPlusGap = this.originalSlideWidth + this.gap;
        const referenceWidth = Math.min(this.carouselWidth, this.maxWidthCarousel || Infinity, window.innerWidth);
        const slideFitting = Math.floor(referenceWidth / slideWidthPlusGap) || 1;
        this.determineSlideToShow(slideFitting);
    }
    /**
     * Determine slide to show
     * Useful to compute the slide displayed on screen and for the slider class.
     * In not responsive mode, the maximum slides to show is determined by the maximum available space and the width of the slide set by the user.
     */
    determineSlideToShow(slideFitting) {
        const maxSlidesToShow = this.responsive
            ? this.initialSlideToShow
            : this.totalSlides;
        this.slideToShow = Math.min(slideFitting, maxSlidesToShow);
    }
    /**
     * Update slide to show (not responsive mode)
     * Computes the number of slide fitting. The number of slides to be shown are determined by the number of slides fitting within its container.
     */
    updateSlideToShowNotResponsive() {
        const slideWidthPlusGap = this.slideWidth + this.gap;
        const referenceWidth = Math.min(this.carouselWidth, this.maxWidthCarousel || Infinity, window.innerWidth);
        const numberOfSlidesComputed = Math.floor(referenceWidth / slideWidthPlusGap) || 1;
        const slideFitting = Math.min(numberOfSlidesComputed, this.totalSlides);
        this.determineSlideToShow(slideFitting);
    }
    getPaddingCarousel() {
        const computedStyle = window.getComputedStyle(this.carousel);
        const paddingLeft = computedStyle.getPropertyValue('padding-left');
        const paddingRight = computedStyle.getPropertyValue('padding-right');
        return parseFloat(paddingLeft) + parseFloat(paddingRight);
    }
    setMaxWidthCarousel() {
        this.carousel.style.maxWidth = `${this.maxWidthCarousel}px`;
    }
    /**
     * Set the with of a slide, responsive mode
     * There are [n cards - 1] gaps (3 cards, 2 gaps)
     */
    setAutoColumnSlideContainer() {
        const windowWidth = this.carouselWidth -
            this.paddingCarousel -
            (this.slideToShow - 1) * this.gap;
        const widthPerSlide = windowWidth / this.slideToShow;
        this.slidesContainer.style.gridAutoColumns = `${widthPerSlide}px`;
        this.slideWidth = widthPerSlide;
    }
    /**
     * Define the slide container width
     * Make non visible gaps of non visible cards scrollable and is used to compute the maxScrollableContent (strechingEffect)
     */
    setWidthSlideContainer() {
        this.widthSlideContainer =
            this.selectSlides().length * this.slideWidthWithGap - this.gap;
        this.slidesContainer.style.width = `${this.widthSlideContainer}px`;
    }
    selectSlides() {
        return this.carousel.querySelectorAll('.carousel-slide');
    }
    slidesToArray() {
        return Array.from(this.slides);
    }
    selectSlidesContainer() {
        return this.carousel.querySelector('.slides-container');
    }
    /**
     * Set number of dots
     * If infinite mode, one more window than normal mode.
     */
    setNumberDots() {
        if (this.loop) {
            return this.totalSlides === this.slideToShow ? 1 : this.totalSlides;
        }
        return this.slideToShow > 1
            ? this.totalSlides - this.slideToShow + 1
            : this.totalSlides;
    }
    /**
     * Get the max scrollable content
     * Useful for the streching effect (not infinite mode), end of the slides
     */
    getMaxScroll() {
        return (this.numberDots - 1) * this.slideWidthWithGap;
    }
    setDraggableImgToFalse() {
        const images = this.slidesContainer.querySelectorAll('img');
        images?.forEach((image) => {
            image.setAttribute('draggable', 'false');
        });
    }
}

class Slider {
    constructor(carousel, responsive, slideToScroll, LIMIT_AUTO_SLIDE, strechingLimit, autoSlide, animationTimingFn, animationTimingMs, MAX_DOM_SIZE, enableMouseDrag, enableTouch, infinite, carouselService) {
        this.carousel = carousel;
        this.responsive = responsive;
        this.slideToScroll = slideToScroll;
        this.LIMIT_AUTO_SLIDE = LIMIT_AUTO_SLIDE;
        this.strechingLimit = strechingLimit;
        this.autoSlide = autoSlide;
        this.animationTimingFn = animationTimingFn;
        this.animationTimingMs = animationTimingMs;
        this.MAX_DOM_SIZE = MAX_DOM_SIZE;
        this.enableMouseDrag = enableMouseDrag;
        this.enableTouch = enableTouch;
        this.infinite = infinite;
        this.carouselService = carouselService;
        this.dragging = false;
        this.currentSlide = 0;
        this.lastWindow = 0;
        this.currentTranslation = 0;
        this.previousTranslation = 0;
        this.direction = 'right';
        this.startX = 0;
        this.previousX = 0;
        this.currentX = 0;
        this.positionChange = 0;
        this.prevLimit = 0;
        this.nextLimit = 0;
        this.initialFullWidth = 0;
        this.lastWindowTranslation = 0;
        this.totalSlides = 0;
        this.DOMLimitReached = false;
        this.visibleOffsetCardNotResponsive = 0;
        this.invisibleOffsetCardNotResponsive = 0;
        this.accumulatedSlide = 0;
        this.currentCarouselID = 0;
        this.initProperties();
        this.updateProperties();
        this.addSlidesToRightAtStart();
    }
    initProperties() {
        this.slidesContainer = this.carousel.slidesContainer;
        this.arrayOfSlides = this.carousel.arrayOfSlides;
        this.totalSlides = this.carousel.totalSlides;
        this.totalAmountOfSlides = this.totalSlides;
        this.nextLimit = Math.floor(this.carousel.slideWidthWithGap);
        this.prevLimit = -this.carousel.slideWidthWithGap;
        this.carouselService.carouselID += 1;
        this.currentCarouselID = this.carouselService.carouselID;
    }
    /**
     * Update properties of the slider
     * Fired at start and at resizing.
     */
    updateProperties() {
        this.lastWindow = this.carousel.numberDots - 1;
        this.updateNotResponsive();
        this.initialFullWidth = this.totalSlides * this.carousel.slideWidthWithGap;
        this.lastWindowTranslation =
            this.slidesContainer.clientWidth -
                this.carousel.slideToShow * this.carousel.slideWidthWithGap +
                this.carousel.gap;
        this.lastWindowTranslation += this.responsive
            ? 0
            : -this.visibleOffsetCardNotResponsive - this.carousel.gap;
        this.carousel.maxScrollableContent =
            this.carousel.widthSlideContainer -
                this.carousel.carouselWidth +
                this.carousel.paddingCarousel;
        if (this.carousel.numberDots === 1) {
            // if all slides visible in one window, max scrollable content equals 0
            this.carousel.maxScrollableContent = 0;
        }
    }
    updateNotResponsive() {
        if (this.responsive)
            return;
        // visible part of the offset of the card in px
        this.visibleOffsetCardNotResponsive =
            this.carousel.carouselWidth -
                this.carousel.slideToShow * this.carousel.slideWidthWithGap -
                this.carousel.paddingCarousel;
        this.invisibleOffsetCardNotResponsive =
            this.carousel.slideWidth - this.visibleOffsetCardNotResponsive;
    }
    /**
     * Add slides to the right at start
     * If only one window (number of dots === 1) and not responsive mode, there is possibly space at start for slides to the right (even though this configuration does not make a lot of sense)
     */
    addSlidesToRightAtStart() {
        if (this.carousel.numberDots > 1 || this.responsive || !this.infinite) {
            return;
        }
        this.addSlidesToTheRight();
    }
    /**
     * Fired at drag start
     * Instantiate property of the starting drag point on the X axis. Used to compute the translation.
     * Disabling the transition while applying the transformation because of the attached animation.
     */
    dragStart(event) {
        if (this.currentEventIsDisabled(event))
            return;
        this.dragging = true;
        this.startX =
            event instanceof MouseEvent ? event.pageX : event.touches[0].pageX;
        // Useful for direction detection
        this.previousX = this.startX;
        this.slidesContainer.style.transition = 'none';
    }
    /**
     * Fired at drag end
     * If not infinite mode and limits reached (start or end), put back to the current slide. Updates previous translation.
     */
    dragStop(event) {
        if (this.currentEventIsDisabled(event))
            return;
        this.dragging = false;
        this.previousTranslation = this.currentTranslation;
        if (this.autoSlide)
            this.autoSlider();
        if (this.infinite)
            return;
        const limit = this.currentTranslation > 0 ||
            -this.currentTranslation > this.lastWindowTranslation;
        if (limit) {
            this.computeTransformation(this.currentSlide);
        }
    }
    currentEventIsDisabled(event) {
        return ((event instanceof MouseEvent && !this.enableMouseDrag) ||
            (event instanceof TouchEvent && !this.enableTouch));
    }
    /**
     * Update the direction
     * Do not update the direction in case of the same previous position.
     */
    setDirection() {
        if (this.previousX > this.currentX) {
            this.direction = 'right';
        }
        else if (this.previousX < this.currentX) {
            this.direction = 'left';
        }
    }
    /**
     * Fired at dragging
     * Compute the translation, change the slide number, update the direction.
     */
    dragMove(event) {
        if (this.currentEventIsDisabled(event))
            return;
        if (!this.dragging)
            return;
        this.currentX =
            event instanceof MouseEvent ? event.pageX : event.changedTouches[0].pageX;
        this.setDirection();
        this.previousX = this.currentX;
        this.positionChange = this.currentX - this.startX;
        this.currentTranslation = this.positionChange + this.previousTranslation;
        // Current translation exceeding start of end limits, finite mode
        if (!this.infinite) {
            if (this.strechingEffect())
                return;
        }
        this.slidesContainer.style.transform = `translate3d(${this.currentTranslation}px, 0, 0)`;
        this.modifyCurrentSlide();
    }
    strechingEffect() {
        return ((this.currentTranslation > this.strechingLimit &&
            this.currentSlide === 0) ||
            this.currentTranslation <
                -this.carousel.maxScrollableContent - this.strechingLimit);
    }
    /**
     * Modify current slide
     * Take into account finite and infinite mode and auto slide.
     * Responsible for changing slide number and updating the limits.
     * If createSlidesInfiniteModeIfLimitsReached() doesn't take action, slide change according to previous computed limits.
     * In finite mode, if all slides visible on one window or end of carousel, early return to not trigger Rxjs Subject.
     */
    modifyCurrentSlide() {
        if (this.infinite) {
            if (this.createSlidesInfiniteModeIfLimits())
                return;
        }
        if (!this.infinite &&
            (this.carousel.numberDots === 1 ||
                (this.currentSlide === this.lastWindow && this.direction === 'right'))) {
            return;
        }
        if (-this.currentTranslation < this.prevLimit) {
            this.changeSlideNumber(-1);
            this.decreaseLimits();
        }
        else if (-this.currentTranslation >= this.nextLimit) {
            this.changeSlideNumber(1);
            this.increaseLimits();
        }
    }
    /**
     * Handle slide creation in infinite mode if limits reached
     * Mouse or touch drag.
     */
    createSlidesInfiniteModeIfLimits() {
        if (this.currentTranslation > 0) {
            this.addSlidesToTheLeft();
            this.decreaseLimits(true);
            // not enabled at start
            if (this.currentSlide > 0) {
                this.changeSlideNumber(-1);
            }
            return true;
        }
        else if (-this.currentTranslation > this.lastWindowTranslation) {
            this.addSlidesToTheRight();
            if (this.DOMLimitReached) {
                this.changePrevAndNextLimits(this.accumulatedSlide);
                return true;
            }
        }
        return false;
    }
    /**
     * Auto slide card if option enabled, applied on both directions.
     * Prevents auto slide on limits in finite mode (if streching < limit auto slide).
     * If only one slide is displayed (slideToShow === 1), the width of the slide corresponds to the window's width (a dot). Hence, taking the min between the two.
     * In non responsive and non infinite, there is possibly an offset of the current limit.
     */
    autoSlider() {
        if (!this.infinite &&
            (this.currentTranslation > 0 ||
                -this.currentTranslation > this.lastWindowTranslation)) {
            return;
        }
        const referenceWidth = Math.min(this.carousel.slideWidth, this.carousel.slideMaxWidth || Infinity);
        let currentLimit = this.prevLimit + this.carousel.slideWidthWithGap;
        if (!this.responsive &&
            !this.infinite &&
            this.currentSlide > this.lastWindow - 1) {
            currentLimit = this.lastWindowTranslation;
        }
        // previousTranslation always a negative number, currentLimit always positive
        const currentPositionChange = this.previousTranslation + currentLimit;
        const moveComparedToSlide = (currentPositionChange / referenceWidth) * 100;
        if (moveComparedToSlide < -this.LIMIT_AUTO_SLIDE ||
            moveComparedToSlide > this.LIMIT_AUTO_SLIDE) {
            if (moveComparedToSlide > this.LIMIT_AUTO_SLIDE) {
                this.changeSlideNumber(-1);
                this.decreaseLimits();
            }
            else {
                this.changeSlideNumber(1);
                this.increaseLimits();
                if (-this.currentTranslation > this.lastWindowTranslation &&
                    this.infinite) {
                    this.addSlidesToTheRight();
                }
            }
            this.computeTransformation(this.accumulatedSlide);
        }
        else {
            // put back to current slide
            this.computeTransformation(this.accumulatedSlide);
        }
    }
    /**
     * Append or prepend new slides according to the direction
     * If new slides prepended, update the translation to the correct place (appending new slides do not change the translation).
     * Limit DOM growth or update last window translation if applicable.
     */
    appendOrPrependNElements() {
        if (this.direction === 'left') {
            for (let i = this.arrayOfSlides.length - 1; i >= 0; i--) {
                const clonedElement = this.arrayOfSlides[i].cloneNode(true);
                this.slidesContainer.prepend(clonedElement);
            }
            this.accumulatedSlide += this.totalSlides;
            this.resetViewLeftDirection();
        }
        else {
            for (let i = 0; i < this.arrayOfSlides.length; i++) {
                const clonedElement = this.arrayOfSlides[i].cloneNode(true);
                this.slidesContainer.append(clonedElement);
            }
        }
        if (this.totalAmountOfSlides >= this.MAX_DOM_SIZE * this.totalSlides) {
            // Limit DOM growth, max X times original DOM
            // console.log('dom limit reached');
            this.limitDOMGrowth();
            this.DOMLimitReached = true;
        }
        else {
            this.totalAmountOfSlides += this.totalSlides;
            this.DOMLimitReached = false;
            this.updateLastWindowTranslation();
        }
    }
    /**
     * Limit DOM growth
     * Reset the view accordingly.
     */
    limitDOMGrowth() {
        const slides = this.carousel.selectSlides();
        if (this.direction === 'right') {
            for (let i = 0; i < this.totalSlides; i++) {
                slides[i].remove();
            }
            this.resetViewRightDirection();
            this.accumulatedSlide -= this.totalSlides;
        }
        else {
            for (let i = slides.length - 1; i > slides.length - this.totalSlides - 1; i--) {
                slides[i].remove();
            }
        }
    }
    /**
     * Reset the view in a movement to the left
     * New slides added to the left, so the view has to be updated accordingly.
     * If the carousel is moved with the mouse | touch event (dragging is true), the offset should be equal to a full carousel width. Otherwise (with the buttons), the computed translation should be taken into account.
     * Side comment: the view does not have to be updated for slides added to the right, since relative order does not change.
     * getBoundingClientRect triggers reflow of the element.
     */
    resetViewLeftDirection() {
        const translation = Math.abs(this.previousTranslation) + this.initialFullWidth;
        this.previousTranslation = -translation;
        this.slidesContainer.style.transition = 'none';
        this.slidesContainer.style.transform = `translate3d(${this.dragging ? -this.initialFullWidth : -translation}px, 0px, 0px)`;
        this.slidesContainer.getBoundingClientRect();
    }
    /**
     * Reset the view in a movement to the right
     * First set of slides have been deleted, so the translation has to be updated accordingly.
     * currentTranslation is a negative number so it will be decreased by a set of slides.
     * getBoundingClientRect triggers reflow of the element.
     */
    resetViewRightDirection() {
        const translation = this.currentTranslation + this.initialFullWidth;
        this.slidesContainer.style.transition = 'none';
        this.slidesContainer.style.transform = `translate3d(${translation}px, 0px, 0px)`;
        this.previousTranslation = translation - this.positionChange;
        this.slidesContainer.getBoundingClientRect();
    }
    /**
     * Update the last window translation
     * Useful to get the max translation at the end of the slides.
     * In not responsive mode, there is possibly a not fully displayed card (card offset).
     */
    updateLastWindowTranslation() {
        const total = this.totalAmountOfSlides * this.carousel.slideWidthWithGap;
        this.lastWindowTranslation =
            total - this.carousel.slideToShow * this.carousel.slideWidthWithGap;
        this.lastWindowTranslation += this.responsive
            ? 0
            : -this.visibleOffsetCardNotResponsive - this.carousel.gap;
    }
    addSlidesToTheLeft() {
        this.appendOrPrependNElements();
    }
    addSlidesToTheRight() {
        this.appendOrPrependNElements();
    }
    /**
     * Decrease limit (movement to the left)
     * In infinite mode, take full width of a set if on the first slide as new slides are created to the left (a whole set offset).
     * Exception: if not responsive (card offset) and finite carousel, the next limit is at the maximum (the end of the carousel)
     */
    decreaseLimits(slidesCreatedOnTheLeft = false) {
        let translationCorrectionAfterClone = this.prevLimit;
        if (slidesCreatedOnTheLeft) {
            translationCorrectionAfterClone = this.initialFullWidth;
        }
        this.prevLimit =
            translationCorrectionAfterClone - this.carousel.slideWidthWithGap;
        this.nextLimit = this.prevLimit + 2 * this.carousel.slideWidthWithGap;
        if (!this.responsive &&
            !this.infinite &&
            this.currentSlide >= this.lastWindow - 1) {
            this.nextLimit = this.lastWindowTranslation;
        }
        this.prevLimit = Math.floor(this.prevLimit);
        this.nextLimit = Math.floor(this.nextLimit);
        // console.log(this.prevLimit, this.nextLimit);
    }
    /**
     * Increase limit on basis of previous computed limits (movement to the right)
     * Schema: || previous | current || next
     * Exception: if not responsive (card offset) and finite carousel, the next limit is at the maximum (the end of the carousel)
     */
    increaseLimits() {
        this.nextLimit += Math.floor(this.carousel.slideWidthWithGap);
        this.prevLimit = Math.floor(this.nextLimit - this.carousel.slideWidthWithGap * 2);
        if (!this.responsive &&
            !this.infinite &&
            this.currentSlide >= this.lastWindow - 1) {
            this.nextLimit = this.lastWindowTranslation;
            if (this.currentSlide === this.lastWindow) {
                // only update previous limit if last slide reached
                this.prevLimit = Math.floor(this.nextLimit - this.invisibleOffsetCardNotResponsive);
            }
        }
        // console.log(this.prevLimit, this.nextLimit);
    }
    /**
     * Change prev and next limit on basis of the provided slide number
     * Prev and next limit are always calculated as the following:
     * || <= prev | current || <= next
     */
    changePrevAndNextLimits(slideNumber) {
        const limitInPX = slideNumber * this.carousel.slideWidthWithGap;
        this.nextLimit = Math.floor(limitInPX + this.carousel.slideWidthWithGap);
        this.prevLimit = Math.floor(this.nextLimit - this.carousel.slideWidthWithGap * 2);
        // console.log(this.prevLimit, this.nextLimit);
    }
    /**
     * Previous button navigation
     */
    prev() {
        this.direction = 'left';
        if (this.infinite) {
            this.handleBtnInfinite(-this.slideToScroll);
        }
        this.changeSlideNumber(-this.slideToScroll);
        this.changePrevAndNextLimits(this.accumulatedSlide);
        this.computeTransformation(this.accumulatedSlide);
    }
    /**
     * Next button navigation
     */
    next() {
        this.direction = 'right';
        if (this.infinite) {
            this.handleBtnInfinite(this.slideToScroll);
        }
        this.changeSlideNumber(this.slideToScroll);
        this.changePrevAndNextLimits(this.accumulatedSlide);
        this.computeTransformation(this.accumulatedSlide);
    }
    /**
     * Buttons navigation in infinite mode
     * Create new slide if limits reached (start or end). Update slide, limits and apply transformation accordingly.
     */
    handleBtnInfinite(step) {
        let cardOffset = 0;
        const goingTo = this.accumulatedSlide + step;
        // there is (possibly) a card offset if not responsive
        if (!this.responsive)
            cardOffset = 1;
        if (goingTo < 0) {
            this.addSlidesToTheLeft();
        }
        else if (goingTo + this.carousel.slideToShow + cardOffset >
            this.totalAmountOfSlides) {
            this.addSlidesToTheRight();
        }
    }
    /**
     * Navigation with bullet points
     * Update values accordingly.
     */
    goTo(bullet) {
        this.direction = this.currentSlide < bullet ? 'right' : 'left';
        this.currentSlide = bullet;
        this.carouselService.onChange(this.currentSlide, this.currentCarouselID);
        if (this.infinite) {
            this.navInfiniteBullets(bullet);
            return;
        }
        this.accumulatedSlide = this.currentSlide;
        this.changePrevAndNextLimits(bullet);
        this.computeTransformation(bullet);
    }
    /**
     * Bullets navigation
     * Create new slides if exceeding end of carousel.
     */
    navInfiniteBullets(bullet) {
        let cardOffset = 0;
        const positionOfCurrentSlide = this.accumulatedSlide % this.totalSlides;
        const difference = bullet - positionOfCurrentSlide;
        this.accumulatedSlide += difference;
        // there is (possibly) a card offset if not responsive
        if (!this.responsive)
            cardOffset = 1;
        if (this.accumulatedSlide + this.carousel.slideToShow + cardOffset >
            this.totalAmountOfSlides) {
            this.addSlidesToTheRight();
        }
        this.computeTransformation(this.accumulatedSlide);
        this.changePrevAndNextLimits(this.accumulatedSlide);
    }
    /**
     * Responsible for changing slide number in finite and infinite mode
     * Exception: if only one window (numberDots === 1), update the accumulatedSlide to let the transformation occurs, but currentSlide should stay at 0.
     */
    changeSlideNumber(step) {
        if (this.infinite) {
            this.infiniteChangeSlideNumber(step);
        }
        else {
            this.finiteChangeSlideNumber(step);
        }
        if (this.carousel.numberDots === 1) {
            this.currentSlide = 0;
        }
        const current = this.carousel.numberDots > 1 ? this.currentSlide : this.accumulatedSlide;
        this.carouselService.onChange(current, this.currentCarouselID);
    }
    infiniteChangeSlideNumber(step) {
        this.accumulatedSlide += step;
        this.currentSlide += step;
        if (this.currentSlide > this.lastWindow) {
            const surplus = this.currentSlide % this.lastWindow;
            this.currentSlide = surplus - 1;
        }
        else if (this.currentSlide < 0) {
            const surplus = this.currentSlide % this.lastWindow;
            this.currentSlide = this.totalSlides + surplus;
        }
    }
    finiteChangeSlideNumber(step) {
        this.currentSlide += step;
        if (this.currentSlide > this.lastWindow) {
            this.currentSlide = this.lastWindow;
        }
        else if (this.currentSlide < 0) {
            this.currentSlide = 0;
        }
        this.accumulatedSlide = this.currentSlide;
    }
    /**
     * Compute transformation that will be applied on basis of the provided slide number
     * Exception: if not responsive (card offset) and finite carousel, the next limit is the end of the carousel
     */
    computeTransformation(slide) {
        let transformation = slide * this.carousel.slideWidthWithGap;
        if (!this.responsive &&
            !this.infinite &&
            slide >= this.lastWindow - 1 &&
            this.carousel.numberDots > 1) {
            this.nextLimit = this.lastWindowTranslation;
            if (slide === this.lastWindow) {
                // if last window, go to maximum & update prev limit
                transformation = this.lastWindowTranslation;
                this.prevLimit = Math.floor(this.nextLimit - this.invisibleOffsetCardNotResponsive);
            }
        }
        this.applyTransformation(transformation);
    }
    applyTransformation(transformation) {
        this.slidesContainer.style.transition = `transform ${this.animationTimingMs}ms ${this.animationTimingFn}`;
        this.slidesContainer.style.transform = `translate3d(${-transformation}px, 0px, 0px)`;
        this.dragging = false;
        this.previousTranslation = -transformation;
        this.currentTranslation = -transformation;
    }
    /**
     * Trigger drag stop
     * If client leaves the page (navigating to another tab) and comes back, stop the dragging.
     * Correct Typescript typing not possible?
     */
    unActiveTab(event) {
        if (event.target.visibilityState === 'visible') {
            this.dragStop(event);
        }
    }
}

class Validation {
    constructor(carousel, slideWidth, slideMaxWidth, gap) {
        this.carousel = carousel;
        this.slideWidth = slideWidth;
        this.slideMaxWidth = slideMaxWidth;
        this.gap = gap;
        this.slideMaxWidthShouldBeGreaterThanSlideWidth();
        this.slideWidthAndGapShouldBeGreaterThanZero();
        this.requiredClassShouldBeAdded();
    }
    slideMaxWidthShouldBeGreaterThanSlideWidth() {
        if (this.slideMaxWidth < this.slideWidth) {
            throw new Error(`slideMaxWidth (value: ${this.slideMaxWidth}) is lower than slideWidth (value: ${this.slideWidth}). Please increase the max width or decrease the slide width.`);
        }
    }
    slideWidthAndGapShouldBeGreaterThanZero() {
        const slideWidthPlusGap = this.slideWidth + this.gap;
        if (slideWidthPlusGap <= 0) {
            throw new Error('Unable to construct Carousel. SlideWidth and gap lower or equal than zero. Please add a positive value for the slideWidth and gap.');
        }
    }
    requiredClassShouldBeAdded() {
        const carouselSlides = this.carousel.querySelectorAll('.carousel-slide');
        if (carouselSlides.length === 0) {
            throw new Error('No elements with "carousel-slide" as class have been found. Please add this class to each of your cards/slides.');
        }
    }
}

class CarouselService {
    constructor() {
        /**
         * An RXJS Subject that will be triggered at every slide change. Returns an object containing the zero indexed current slide number and the zero indexed carousel ID.
         */
        this.onSlideChange = new Subject();
        /**
         * Internal use only.
         */
        this.carouselID = -1;
    }
    /**
     * Internal use only.
     */
    onChange(slide, currentCarouselID) {
        this.onSlideChange.next({ slide, carouselID: currentCarouselID });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: CarouselService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: CarouselService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: CarouselService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class CarouselComponent {
    constructor(elementRef, changeDetection, carouselService, platformId) {
        this.elementRef = elementRef;
        this.changeDetection = changeDetection;
        this.carouselService = carouselService;
        this.infinite = false;
        this.responsive = true;
        this.autoSlide = true;
        this.slideToShow = 3;
        this.slideToScroll = 2;
        this.autoslideLimitPercentCard = 30;
        this.strechingLimit = 60;
        this.slideWidth = 300;
        this.slideMaxWidth = 500;
        this.dots = true;
        this.arrows = true;
        this.counter = true;
        this.enableMouseDrag = true;
        this.enableTouch = true;
        this.counterSeparator = '/';
        this.gapBetweenSlides = 16;
        this.animationTimingMs = 300;
        this.maxDomSize = 4;
        this.animationTimingFn = 'ease-out';
        this.isBrowser = true;
        this.isBrowser = isPlatformBrowser(platformId);
    }
    ngAfterViewInit() {
        if (!this.isBrowser)
            return;
        const carouselContainer = this.elementRef.nativeElement
            .firstChild;
        new Validation(carouselContainer, this.slideWidth, this.slideMaxWidth, this.gapBetweenSlides);
        this.carousel = new Carousel(carouselContainer, this.maxWidthCarousel, this.slideToShow, this.slideWidth, this.slideMaxWidth, this.gapBetweenSlides, this.responsive, this.infinite);
        this.slider = new Slider(this.carousel, this.responsive, this.slideToScroll, this.autoslideLimitPercentCard, this.strechingLimit, this.autoSlide, this.animationTimingFn, this.animationTimingMs, this.maxDomSize, this.enableMouseDrag, this.enableTouch, this.infinite, this.carouselService);
        this.listeners();
        this.changeDetection.markForCheck();
    }
    ngAfterContentInit() { }
    listeners() {
        this.mouseupSubscription = fromEvent(window, 'mouseup').subscribe((event) => {
            if (!this.slider?.dragging)
                return;
            this.slider?.dragStop(event);
        });
        this.VChangeSubscription = fromEvent(document, 'visibilitychange').subscribe((event) => {
            this.slider?.unActiveTab(event);
        });
        this.resizeSubscription = fromEvent(window, 'resize').subscribe(() => {
            this.resize();
        });
    }
    /**
     * Reinitialise variables at resize
     */
    resize() {
        if (!this.slider)
            return;
        this.carousel?.updateProperties();
        this.slider.updateProperties();
        this.slider.currentSlide = 0;
        this.slider.accumulatedSlide = 0;
        this.slider.computeTransformation(0);
        this.slider.changePrevAndNextLimits(0);
        this.carouselService.onChange(this.slider.currentSlide, this.slider.currentCarouselID);
        this.changeDetection.markForCheck();
    }
    ngOnDestroy() {
        this.mouseupSubscription?.unsubscribe();
        this.VChangeSubscription?.unsubscribe();
        this.resizeSubscription?.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: CarouselComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: CarouselService }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.8", type: CarouselComponent, isStandalone: true, selector: "carousel", inputs: { maxWidthCarousel: "maxWidthCarousel", infinite: "infinite", responsive: "responsive", autoSlide: "autoSlide", slideToShow: "slideToShow", slideToScroll: "slideToScroll", autoslideLimitPercentCard: "autoslideLimitPercentCard", strechingLimit: "strechingLimit", slideWidth: "slideWidth", slideMaxWidth: "slideMaxWidth", dots: "dots", arrows: "arrows", counter: "counter", enableMouseDrag: "enableMouseDrag", enableTouch: "enableTouch", counterSeparator: "counterSeparator", gapBetweenSlides: "gapBetweenSlides", animationTimingMs: "animationTimingMs", maxDomSize: "maxDomSize", animationTimingFn: "animationTimingFn" }, ngImport: i0, template: "<div class=\"carousel-container\">\r\n  <div class=\"banner-container\">\r\n    <div class=\"btn-container\" *ngIf=\"arrows\">\r\n      <button\r\n        class=\"prev\"\r\n        aria-label=\"previous button navigation\"\r\n        (click)=\"slider?.prev()\"\r\n        [disabled]=\"\r\n          !infinite &&\r\n          ((slider?.currentSlide === 0 &&\r\n            (slider?.currentTranslation || 0) >= 0) ||\r\n            carousel?.numberDots === 1)\r\n        \"\r\n      >\r\n        <svg\r\n          xmlns=\"http://www.w3.org/2000/svg\"\r\n          height=\"16\"\r\n          width=\"16\"\r\n          viewBox=\"0 0 512 512\"\r\n        >\r\n          <path\r\n            d=\"M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 288 480 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-370.7 0 73.4-73.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-128 128z\"\r\n          />\r\n        </svg>\r\n      </button>\r\n      <button\r\n        class=\"next\"\r\n        aria-label=\"next button navigation\"\r\n        (click)=\"slider?.next()\"\r\n        [disabled]=\"\r\n          !infinite &&\r\n          ((slider?.currentSlide === (carousel?.numberDots || 0) - 1 &&\r\n            (slider?.currentTranslation || 0) <=\r\n              -(carousel?.maxScrollableContent || 0)) ||\r\n            carousel?.numberDots === 1)\r\n        \"\r\n      >\r\n        <svg\r\n          xmlns=\"http://www.w3.org/2000/svg\"\r\n          height=\"16\"\r\n          width=\"16\"\r\n          viewBox=\"0 0 512 512\"\r\n        >\r\n          <path\r\n            d=\"M502.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l370.7 0-73.4 73.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l128-128z\"\r\n          />\r\n        </svg>\r\n      </button>\r\n    </div>\r\n    <div class=\"counter\" *ngIf=\"counter\">\r\n      <p>\r\n        {{ (slider?.currentSlide || 0) + 1 }} {{ counterSeparator }}\r\n        {{ carousel?.numberDots }}\r\n      </p>\r\n    </div>\r\n  </div>\r\n\r\n  <div\r\n    class=\"slides-container\"\r\n    [class.dragging]=\"slider?.dragging\"\r\n    (mousedown)=\"slider?.dragStart($event)\"\r\n    (touchstart)=\"slider?.dragStart($event)\"\r\n    (mousemove)=\"slider?.dragMove($event)\"\r\n    (touchmove)=\"slider?.dragMove($event)\"\r\n    (touchend)=\"slider?.dragStop($event)\"\r\n    #slides\r\n  >\r\n    <ng-content></ng-content>\r\n  </div>\r\n\r\n  <div class=\"bullets-container\" *ngIf=\"dots\">\r\n    <button\r\n      class=\"bullet\"\r\n      aria-label=\"bullet point navigation\"\r\n      *ngFor=\"let bullet of carousel?.arrayNumberDots\"\r\n      [class.current]=\"bullet === slider?.currentSlide\"\r\n      (click)=\"slider?.goTo(bullet)\"\r\n    ></button>\r\n  </div>\r\n</div>\r\n", styles: ["*{margin:0;padding:0;box-sizing:border-box}.carousel-container{position:relative;overflow-x:hidden;padding:.2rem}.slides-container{display:grid;grid-auto-flow:column;justify-items:center;transform:translateZ(0);margin:auto}.banner-container{display:flex;justify-content:space-between;align-items:flex-end;margin-bottom:.5rem}.counter{background:#e6e6e6;padding:.3rem .7rem;border-radius:1rem;min-width:3.75rem;text-align:center}.prev,.next{background:#0079b4;padding:.5rem;color:#fff;border-radius:.3rem;box-shadow:0 2px 4px #9e9e9ed4;border:none;cursor:pointer;z-index:1;transition:.4s}.prev svg,.next svg{fill:#fff}.prev,.next{display:inline-flex;align-items:center;justify-content:center}.prev{margin-right:1rem}.prev:disabled,.next:disabled{opacity:.3;cursor:not-allowed}.bullets-container{display:flex;justify-content:center;gap:1rem;margin-top:2rem}.bullet{display:block;width:.8rem;height:.8rem;border:none;border-radius:50%;background:#dbdada;cursor:pointer;transition:background-color .4s}.bullet.current{background:#0079b4}.slides-container.dragging{cursor:grab}@media (min-width: 650px){.prev,.next{position:absolute;top:50%;left:0;transform:translateY(-50%)}.prev{margin-left:2rem}.next{margin-right:2rem;right:0;left:auto}}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'carousel', imports: [CommonModule], standalone: true, changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"carousel-container\">\r\n  <div class=\"banner-container\">\r\n    <div class=\"btn-container\" *ngIf=\"arrows\">\r\n      <button\r\n        class=\"prev\"\r\n        aria-label=\"previous button navigation\"\r\n        (click)=\"slider?.prev()\"\r\n        [disabled]=\"\r\n          !infinite &&\r\n          ((slider?.currentSlide === 0 &&\r\n            (slider?.currentTranslation || 0) >= 0) ||\r\n            carousel?.numberDots === 1)\r\n        \"\r\n      >\r\n        <svg\r\n          xmlns=\"http://www.w3.org/2000/svg\"\r\n          height=\"16\"\r\n          width=\"16\"\r\n          viewBox=\"0 0 512 512\"\r\n        >\r\n          <path\r\n            d=\"M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 288 480 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-370.7 0 73.4-73.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-128 128z\"\r\n          />\r\n        </svg>\r\n      </button>\r\n      <button\r\n        class=\"next\"\r\n        aria-label=\"next button navigation\"\r\n        (click)=\"slider?.next()\"\r\n        [disabled]=\"\r\n          !infinite &&\r\n          ((slider?.currentSlide === (carousel?.numberDots || 0) - 1 &&\r\n            (slider?.currentTranslation || 0) <=\r\n              -(carousel?.maxScrollableContent || 0)) ||\r\n            carousel?.numberDots === 1)\r\n        \"\r\n      >\r\n        <svg\r\n          xmlns=\"http://www.w3.org/2000/svg\"\r\n          height=\"16\"\r\n          width=\"16\"\r\n          viewBox=\"0 0 512 512\"\r\n        >\r\n          <path\r\n            d=\"M502.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l370.7 0-73.4 73.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l128-128z\"\r\n          />\r\n        </svg>\r\n      </button>\r\n    </div>\r\n    <div class=\"counter\" *ngIf=\"counter\">\r\n      <p>\r\n        {{ (slider?.currentSlide || 0) + 1 }} {{ counterSeparator }}\r\n        {{ carousel?.numberDots }}\r\n      </p>\r\n    </div>\r\n  </div>\r\n\r\n  <div\r\n    class=\"slides-container\"\r\n    [class.dragging]=\"slider?.dragging\"\r\n    (mousedown)=\"slider?.dragStart($event)\"\r\n    (touchstart)=\"slider?.dragStart($event)\"\r\n    (mousemove)=\"slider?.dragMove($event)\"\r\n    (touchmove)=\"slider?.dragMove($event)\"\r\n    (touchend)=\"slider?.dragStop($event)\"\r\n    #slides\r\n  >\r\n    <ng-content></ng-content>\r\n  </div>\r\n\r\n  <div class=\"bullets-container\" *ngIf=\"dots\">\r\n    <button\r\n      class=\"bullet\"\r\n      aria-label=\"bullet point navigation\"\r\n      *ngFor=\"let bullet of carousel?.arrayNumberDots\"\r\n      [class.current]=\"bullet === slider?.currentSlide\"\r\n      (click)=\"slider?.goTo(bullet)\"\r\n    ></button>\r\n  </div>\r\n</div>\r\n", styles: ["*{margin:0;padding:0;box-sizing:border-box}.carousel-container{position:relative;overflow-x:hidden;padding:.2rem}.slides-container{display:grid;grid-auto-flow:column;justify-items:center;transform:translateZ(0);margin:auto}.banner-container{display:flex;justify-content:space-between;align-items:flex-end;margin-bottom:.5rem}.counter{background:#e6e6e6;padding:.3rem .7rem;border-radius:1rem;min-width:3.75rem;text-align:center}.prev,.next{background:#0079b4;padding:.5rem;color:#fff;border-radius:.3rem;box-shadow:0 2px 4px #9e9e9ed4;border:none;cursor:pointer;z-index:1;transition:.4s}.prev svg,.next svg{fill:#fff}.prev,.next{display:inline-flex;align-items:center;justify-content:center}.prev{margin-right:1rem}.prev:disabled,.next:disabled{opacity:.3;cursor:not-allowed}.bullets-container{display:flex;justify-content:center;gap:1rem;margin-top:2rem}.bullet{display:block;width:.8rem;height:.8rem;border:none;border-radius:50%;background:#dbdada;cursor:pointer;transition:background-color .4s}.bullet.current{background:#0079b4}.slides-container.dragging{cursor:grab}@media (min-width: 650px){.prev,.next{position:absolute;top:50%;left:0;transform:translateY(-50%)}.prev{margin-left:2rem}.next{margin-right:2rem;right:0;left:auto}}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: CarouselService }, { type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }], propDecorators: { maxWidthCarousel: [{
                type: Input
            }], infinite: [{
                type: Input
            }], responsive: [{
                type: Input
            }], autoSlide: [{
                type: Input
            }], slideToShow: [{
                type: Input
            }], slideToScroll: [{
                type: Input
            }], autoslideLimitPercentCard: [{
                type: Input
            }], strechingLimit: [{
                type: Input
            }], slideWidth: [{
                type: Input
            }], slideMaxWidth: [{
                type: Input
            }], dots: [{
                type: Input
            }], arrows: [{
                type: Input
            }], counter: [{
                type: Input
            }], enableMouseDrag: [{
                type: Input
            }], enableTouch: [{
                type: Input
            }], counterSeparator: [{
                type: Input
            }], gapBetweenSlides: [{
                type: Input
            }], animationTimingMs: [{
                type: Input
            }], maxDomSize: [{
                type: Input
            }], animationTimingFn: [{
                type: Input
            }] } });

class CarouselModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.0.8", ngImport: i0, type: CarouselModule, imports: [CommonModule, CarouselComponent], exports: [CarouselComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: CarouselModule, imports: [CommonModule, CarouselComponent] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: CarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [],
                    imports: [CommonModule, CarouselComponent],
                    exports: [CarouselComponent],
                }]
        }] });

/*
 * Public API Surface of carousel
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CarouselComponent, CarouselModule, CarouselService };
//# sourceMappingURL=ngx-carousel-ease.mjs.map
