export class Slider {
    constructor(carousel, responsive, slideToScroll, LIMIT_AUTO_SLIDE, strechingLimit, autoSlide, animationTimingFn, animationTimingMs, MAX_DOM_SIZE, enableMouseDrag, enableTouch, infinite, carouselService) {
        this.carousel = carousel;
        this.responsive = responsive;
        this.slideToScroll = slideToScroll;
        this.LIMIT_AUTO_SLIDE = LIMIT_AUTO_SLIDE;
        this.strechingLimit = strechingLimit;
        this.autoSlide = autoSlide;
        this.animationTimingFn = animationTimingFn;
        this.animationTimingMs = animationTimingMs;
        this.MAX_DOM_SIZE = MAX_DOM_SIZE;
        this.enableMouseDrag = enableMouseDrag;
        this.enableTouch = enableTouch;
        this.infinite = infinite;
        this.carouselService = carouselService;
        this.dragging = false;
        this.currentSlide = 0;
        this.lastWindow = 0;
        this.currentTranslation = 0;
        this.previousTranslation = 0;
        this.direction = 'right';
        this.startX = 0;
        this.previousX = 0;
        this.currentX = 0;
        this.positionChange = 0;
        this.prevLimit = 0;
        this.nextLimit = 0;
        this.initialFullWidth = 0;
        this.lastWindowTranslation = 0;
        this.totalSlides = 0;
        this.DOMLimitReached = false;
        this.visibleOffsetCardNotResponsive = 0;
        this.invisibleOffsetCardNotResponsive = 0;
        this.accumulatedSlide = 0;
        this.currentCarouselID = 0;
        this.initProperties();
        this.updateProperties();
        this.addSlidesToRightAtStart();
    }
    initProperties() {
        this.slidesContainer = this.carousel.slidesContainer;
        this.arrayOfSlides = this.carousel.arrayOfSlides;
        this.totalSlides = this.carousel.totalSlides;
        this.totalAmountOfSlides = this.totalSlides;
        this.nextLimit = Math.floor(this.carousel.slideWidthWithGap);
        this.prevLimit = -this.carousel.slideWidthWithGap;
        this.carouselService.carouselID += 1;
        this.currentCarouselID = this.carouselService.carouselID;
    }
    /**
     * Update properties of the slider
     * Fired at start and at resizing.
     */
    updateProperties() {
        this.lastWindow = this.carousel.numberDots - 1;
        this.updateNotResponsive();
        this.initialFullWidth = this.totalSlides * this.carousel.slideWidthWithGap;
        this.lastWindowTranslation =
            this.slidesContainer.clientWidth -
                this.carousel.slideToShow * this.carousel.slideWidthWithGap +
                this.carousel.gap;
        this.lastWindowTranslation += this.responsive
            ? 0
            : -this.visibleOffsetCardNotResponsive - this.carousel.gap;
        this.carousel.maxScrollableContent =
            this.carousel.widthSlideContainer -
                this.carousel.carouselWidth +
                this.carousel.paddingCarousel;
        if (this.carousel.numberDots === 1) {
            // if all slides visible in one window, max scrollable content equals 0
            this.carousel.maxScrollableContent = 0;
        }
    }
    updateNotResponsive() {
        if (this.responsive)
            return;
        // visible part of the offset of the card in px
        this.visibleOffsetCardNotResponsive =
            this.carousel.carouselWidth -
                this.carousel.slideToShow * this.carousel.slideWidthWithGap -
                this.carousel.paddingCarousel;
        this.invisibleOffsetCardNotResponsive =
            this.carousel.slideWidth - this.visibleOffsetCardNotResponsive;
    }
    /**
     * Add slides to the right at start
     * If only one window (number of dots === 1) and not responsive mode, there is possibly space at start for slides to the right (even though this configuration does not make a lot of sense)
     */
    addSlidesToRightAtStart() {
        if (this.carousel.numberDots > 1 || this.responsive || !this.infinite) {
            return;
        }
        this.addSlidesToTheRight();
    }
    /**
     * Fired at drag start
     * Instantiate property of the starting drag point on the X axis. Used to compute the translation.
     * Disabling the transition while applying the transformation because of the attached animation.
     */
    dragStart(event) {
        if (this.currentEventIsDisabled(event))
            return;
        this.dragging = true;
        this.startX =
            event instanceof MouseEvent ? event.pageX : event.touches[0].pageX;
        // Useful for direction detection
        this.previousX = this.startX;
        this.slidesContainer.style.transition = 'none';
    }
    /**
     * Fired at drag end
     * If not infinite mode and limits reached (start or end), put back to the current slide. Updates previous translation.
     */
    dragStop(event) {
        if (this.currentEventIsDisabled(event))
            return;
        this.dragging = false;
        this.previousTranslation = this.currentTranslation;
        if (this.autoSlide)
            this.autoSlider();
        if (this.infinite)
            return;
        const limit = this.currentTranslation > 0 ||
            -this.currentTranslation > this.lastWindowTranslation;
        if (limit) {
            this.computeTransformation(this.currentSlide);
        }
    }
    currentEventIsDisabled(event) {
        return ((event instanceof MouseEvent && !this.enableMouseDrag) ||
            (event instanceof TouchEvent && !this.enableTouch));
    }
    /**
     * Update the direction
     * Do not update the direction in case of the same previous position.
     */
    setDirection() {
        if (this.previousX > this.currentX) {
            this.direction = 'right';
        }
        else if (this.previousX < this.currentX) {
            this.direction = 'left';
        }
    }
    /**
     * Fired at dragging
     * Compute the translation, change the slide number, update the direction.
     */
    dragMove(event) {
        if (this.currentEventIsDisabled(event))
            return;
        if (!this.dragging)
            return;
        this.currentX =
            event instanceof MouseEvent ? event.pageX : event.changedTouches[0].pageX;
        this.setDirection();
        this.previousX = this.currentX;
        this.positionChange = this.currentX - this.startX;
        this.currentTranslation = this.positionChange + this.previousTranslation;
        // Current translation exceeding start of end limits, finite mode
        if (!this.infinite) {
            if (this.strechingEffect())
                return;
        }
        this.slidesContainer.style.transform = `translate3d(${this.currentTranslation}px, 0, 0)`;
        this.modifyCurrentSlide();
    }
    strechingEffect() {
        return ((this.currentTranslation > this.strechingLimit &&
            this.currentSlide === 0) ||
            this.currentTranslation <
                -this.carousel.maxScrollableContent - this.strechingLimit);
    }
    /**
     * Modify current slide
     * Take into account finite and infinite mode and auto slide.
     * Responsible for changing slide number and updating the limits.
     * If createSlidesInfiniteModeIfLimitsReached() doesn't take action, slide change according to previous computed limits.
     * In finite mode, if all slides visible on one window or end of carousel, early return to not trigger Rxjs Subject.
     */
    modifyCurrentSlide() {
        if (this.infinite) {
            if (this.createSlidesInfiniteModeIfLimits())
                return;
        }
        if (!this.infinite &&
            (this.carousel.numberDots === 1 ||
                (this.currentSlide === this.lastWindow && this.direction === 'right'))) {
            return;
        }
        if (-this.currentTranslation < this.prevLimit) {
            this.changeSlideNumber(-1);
            this.decreaseLimits();
        }
        else if (-this.currentTranslation >= this.nextLimit) {
            this.changeSlideNumber(1);
            this.increaseLimits();
        }
    }
    /**
     * Handle slide creation in infinite mode if limits reached
     * Mouse or touch drag.
     */
    createSlidesInfiniteModeIfLimits() {
        if (this.currentTranslation > 0) {
            this.addSlidesToTheLeft();
            this.decreaseLimits(true);
            // not enabled at start
            if (this.currentSlide > 0) {
                this.changeSlideNumber(-1);
            }
            return true;
        }
        else if (-this.currentTranslation > this.lastWindowTranslation) {
            this.addSlidesToTheRight();
            if (this.DOMLimitReached) {
                this.changePrevAndNextLimits(this.accumulatedSlide);
                return true;
            }
        }
        return false;
    }
    /**
     * Auto slide card if option enabled, applied on both directions.
     * Prevents auto slide on limits in finite mode (if streching < limit auto slide).
     * If only one slide is displayed (slideToShow === 1), the width of the slide corresponds to the window's width (a dot). Hence, taking the min between the two.
     * In non responsive and non infinite, there is possibly an offset of the current limit.
     */
    autoSlider() {
        if (!this.infinite &&
            (this.currentTranslation > 0 ||
                -this.currentTranslation > this.lastWindowTranslation)) {
            return;
        }
        const referenceWidth = Math.min(this.carousel.slideWidth, this.carousel.slideMaxWidth || Infinity);
        let currentLimit = this.prevLimit + this.carousel.slideWidthWithGap;
        if (!this.responsive &&
            !this.infinite &&
            this.currentSlide > this.lastWindow - 1) {
            currentLimit = this.lastWindowTranslation;
        }
        // previousTranslation always a negative number, currentLimit always positive
        const currentPositionChange = this.previousTranslation + currentLimit;
        const moveComparedToSlide = (currentPositionChange / referenceWidth) * 100;
        if (moveComparedToSlide < -this.LIMIT_AUTO_SLIDE ||
            moveComparedToSlide > this.LIMIT_AUTO_SLIDE) {
            if (moveComparedToSlide > this.LIMIT_AUTO_SLIDE) {
                this.changeSlideNumber(-1);
                this.decreaseLimits();
            }
            else {
                this.changeSlideNumber(1);
                this.increaseLimits();
                if (-this.currentTranslation > this.lastWindowTranslation &&
                    this.infinite) {
                    this.addSlidesToTheRight();
                }
            }
            this.computeTransformation(this.accumulatedSlide);
        }
        else {
            // put back to current slide
            this.computeTransformation(this.accumulatedSlide);
        }
    }
    /**
     * Append or prepend new slides according to the direction
     * If new slides prepended, update the translation to the correct place (appending new slides do not change the translation).
     * Limit DOM growth or update last window translation if applicable.
     */
    appendOrPrependNElements() {
        if (this.direction === 'left') {
            for (let i = this.arrayOfSlides.length - 1; i >= 0; i--) {
                const clonedElement = this.arrayOfSlides[i].cloneNode(true);
                this.slidesContainer.prepend(clonedElement);
            }
            this.accumulatedSlide += this.totalSlides;
            this.resetViewLeftDirection();
        }
        else {
            for (let i = 0; i < this.arrayOfSlides.length; i++) {
                const clonedElement = this.arrayOfSlides[i].cloneNode(true);
                this.slidesContainer.append(clonedElement);
            }
        }
        if (this.totalAmountOfSlides >= this.MAX_DOM_SIZE * this.totalSlides) {
            // Limit DOM growth, max X times original DOM
            // console.log('dom limit reached');
            this.limitDOMGrowth();
            this.DOMLimitReached = true;
        }
        else {
            this.totalAmountOfSlides += this.totalSlides;
            this.DOMLimitReached = false;
            this.updateLastWindowTranslation();
        }
    }
    /**
     * Limit DOM growth
     * Reset the view accordingly.
     */
    limitDOMGrowth() {
        const slides = this.carousel.selectSlides();
        if (this.direction === 'right') {
            for (let i = 0; i < this.totalSlides; i++) {
                slides[i].remove();
            }
            this.resetViewRightDirection();
            this.accumulatedSlide -= this.totalSlides;
        }
        else {
            for (let i = slides.length - 1; i > slides.length - this.totalSlides - 1; i--) {
                slides[i].remove();
            }
        }
    }
    /**
     * Reset the view in a movement to the left
     * New slides added to the left, so the view has to be updated accordingly.
     * If the carousel is moved with the mouse | touch event (dragging is true), the offset should be equal to a full carousel width. Otherwise (with the buttons), the computed translation should be taken into account.
     * Side comment: the view does not have to be updated for slides added to the right, since relative order does not change.
     * getBoundingClientRect triggers reflow of the element.
     */
    resetViewLeftDirection() {
        const translation = Math.abs(this.previousTranslation) + this.initialFullWidth;
        this.previousTranslation = -translation;
        this.slidesContainer.style.transition = 'none';
        this.slidesContainer.style.transform = `translate3d(${this.dragging ? -this.initialFullWidth : -translation}px, 0px, 0px)`;
        this.slidesContainer.getBoundingClientRect();
    }
    /**
     * Reset the view in a movement to the right
     * First set of slides have been deleted, so the translation has to be updated accordingly.
     * currentTranslation is a negative number so it will be decreased by a set of slides.
     * getBoundingClientRect triggers reflow of the element.
     */
    resetViewRightDirection() {
        const translation = this.currentTranslation + this.initialFullWidth;
        this.slidesContainer.style.transition = 'none';
        this.slidesContainer.style.transform = `translate3d(${translation}px, 0px, 0px)`;
        this.previousTranslation = translation - this.positionChange;
        this.slidesContainer.getBoundingClientRect();
    }
    /**
     * Update the last window translation
     * Useful to get the max translation at the end of the slides.
     * In not responsive mode, there is possibly a not fully displayed card (card offset).
     */
    updateLastWindowTranslation() {
        const total = this.totalAmountOfSlides * this.carousel.slideWidthWithGap;
        this.lastWindowTranslation =
            total - this.carousel.slideToShow * this.carousel.slideWidthWithGap;
        this.lastWindowTranslation += this.responsive
            ? 0
            : -this.visibleOffsetCardNotResponsive - this.carousel.gap;
    }
    addSlidesToTheLeft() {
        this.appendOrPrependNElements();
    }
    addSlidesToTheRight() {
        this.appendOrPrependNElements();
    }
    /**
     * Decrease limit (movement to the left)
     * In infinite mode, take full width of a set if on the first slide as new slides are created to the left (a whole set offset).
     * Exception: if not responsive (card offset) and finite carousel, the next limit is at the maximum (the end of the carousel)
     */
    decreaseLimits(slidesCreatedOnTheLeft = false) {
        let translationCorrectionAfterClone = this.prevLimit;
        if (slidesCreatedOnTheLeft) {
            translationCorrectionAfterClone = this.initialFullWidth;
        }
        this.prevLimit =
            translationCorrectionAfterClone - this.carousel.slideWidthWithGap;
        this.nextLimit = this.prevLimit + 2 * this.carousel.slideWidthWithGap;
        if (!this.responsive &&
            !this.infinite &&
            this.currentSlide >= this.lastWindow - 1) {
            this.nextLimit = this.lastWindowTranslation;
        }
        this.prevLimit = Math.floor(this.prevLimit);
        this.nextLimit = Math.floor(this.nextLimit);
        // console.log(this.prevLimit, this.nextLimit);
    }
    /**
     * Increase limit on basis of previous computed limits (movement to the right)
     * Schema: || previous | current || next
     * Exception: if not responsive (card offset) and finite carousel, the next limit is at the maximum (the end of the carousel)
     */
    increaseLimits() {
        this.nextLimit += Math.floor(this.carousel.slideWidthWithGap);
        this.prevLimit = Math.floor(this.nextLimit - this.carousel.slideWidthWithGap * 2);
        if (!this.responsive &&
            !this.infinite &&
            this.currentSlide >= this.lastWindow - 1) {
            this.nextLimit = this.lastWindowTranslation;
            if (this.currentSlide === this.lastWindow) {
                // only update previous limit if last slide reached
                this.prevLimit = Math.floor(this.nextLimit - this.invisibleOffsetCardNotResponsive);
            }
        }
        // console.log(this.prevLimit, this.nextLimit);
    }
    /**
     * Change prev and next limit on basis of the provided slide number
     * Prev and next limit are always calculated as the following:
     * || <= prev | current || <= next
     */
    changePrevAndNextLimits(slideNumber) {
        const limitInPX = slideNumber * this.carousel.slideWidthWithGap;
        this.nextLimit = Math.floor(limitInPX + this.carousel.slideWidthWithGap);
        this.prevLimit = Math.floor(this.nextLimit - this.carousel.slideWidthWithGap * 2);
        // console.log(this.prevLimit, this.nextLimit);
    }
    /**
     * Previous button navigation
     */
    prev() {
        this.direction = 'left';
        if (this.infinite) {
            this.handleBtnInfinite(-this.slideToScroll);
        }
        this.changeSlideNumber(-this.slideToScroll);
        this.changePrevAndNextLimits(this.accumulatedSlide);
        this.computeTransformation(this.accumulatedSlide);
    }
    /**
     * Next button navigation
     */
    next() {
        this.direction = 'right';
        if (this.infinite) {
            this.handleBtnInfinite(this.slideToScroll);
        }
        this.changeSlideNumber(this.slideToScroll);
        this.changePrevAndNextLimits(this.accumulatedSlide);
        this.computeTransformation(this.accumulatedSlide);
    }
    /**
     * Buttons navigation in infinite mode
     * Create new slide if limits reached (start or end). Update slide, limits and apply transformation accordingly.
     */
    handleBtnInfinite(step) {
        let cardOffset = 0;
        const goingTo = this.accumulatedSlide + step;
        // there is (possibly) a card offset if not responsive
        if (!this.responsive)
            cardOffset = 1;
        if (goingTo < 0) {
            this.addSlidesToTheLeft();
        }
        else if (goingTo + this.carousel.slideToShow + cardOffset >
            this.totalAmountOfSlides) {
            this.addSlidesToTheRight();
        }
    }
    /**
     * Navigation with bullet points
     * Update values accordingly.
     */
    goTo(bullet) {
        this.direction = this.currentSlide < bullet ? 'right' : 'left';
        this.currentSlide = bullet;
        this.carouselService.onChange(this.currentSlide, this.currentCarouselID);
        if (this.infinite) {
            this.navInfiniteBullets(bullet);
            return;
        }
        this.accumulatedSlide = this.currentSlide;
        this.changePrevAndNextLimits(bullet);
        this.computeTransformation(bullet);
    }
    /**
     * Bullets navigation
     * Create new slides if exceeding end of carousel.
     */
    navInfiniteBullets(bullet) {
        let cardOffset = 0;
        const positionOfCurrentSlide = this.accumulatedSlide % this.totalSlides;
        const difference = bullet - positionOfCurrentSlide;
        this.accumulatedSlide += difference;
        // there is (possibly) a card offset if not responsive
        if (!this.responsive)
            cardOffset = 1;
        if (this.accumulatedSlide + this.carousel.slideToShow + cardOffset >
            this.totalAmountOfSlides) {
            this.addSlidesToTheRight();
        }
        this.computeTransformation(this.accumulatedSlide);
        this.changePrevAndNextLimits(this.accumulatedSlide);
    }
    /**
     * Responsible for changing slide number in finite and infinite mode
     * Exception: if only one window (numberDots === 1), update the accumulatedSlide to let the transformation occurs, but currentSlide should stay at 0.
     */
    changeSlideNumber(step) {
        if (this.infinite) {
            this.infiniteChangeSlideNumber(step);
        }
        else {
            this.finiteChangeSlideNumber(step);
        }
        if (this.carousel.numberDots === 1) {
            this.currentSlide = 0;
        }
        const current = this.carousel.numberDots > 1 ? this.currentSlide : this.accumulatedSlide;
        this.carouselService.onChange(current, this.currentCarouselID);
    }
    infiniteChangeSlideNumber(step) {
        this.accumulatedSlide += step;
        this.currentSlide += step;
        if (this.currentSlide > this.lastWindow) {
            const surplus = this.currentSlide % this.lastWindow;
            this.currentSlide = surplus - 1;
        }
        else if (this.currentSlide < 0) {
            const surplus = this.currentSlide % this.lastWindow;
            this.currentSlide = this.totalSlides + surplus;
        }
    }
    finiteChangeSlideNumber(step) {
        this.currentSlide += step;
        if (this.currentSlide > this.lastWindow) {
            this.currentSlide = this.lastWindow;
        }
        else if (this.currentSlide < 0) {
            this.currentSlide = 0;
        }
        this.accumulatedSlide = this.currentSlide;
    }
    /**
     * Compute transformation that will be applied on basis of the provided slide number
     * Exception: if not responsive (card offset) and finite carousel, the next limit is the end of the carousel
     */
    computeTransformation(slide) {
        let transformation = slide * this.carousel.slideWidthWithGap;
        if (!this.responsive &&
            !this.infinite &&
            slide >= this.lastWindow - 1 &&
            this.carousel.numberDots > 1) {
            this.nextLimit = this.lastWindowTranslation;
            if (slide === this.lastWindow) {
                // if last window, go to maximum & update prev limit
                transformation = this.lastWindowTranslation;
                this.prevLimit = Math.floor(this.nextLimit - this.invisibleOffsetCardNotResponsive);
            }
        }
        this.applyTransformation(transformation);
    }
    applyTransformation(transformation) {
        this.slidesContainer.style.transition = `transform ${this.animationTimingMs}ms ${this.animationTimingFn}`;
        this.slidesContainer.style.transform = `translate3d(${-transformation}px, 0px, 0px)`;
        this.dragging = false;
        this.previousTranslation = -transformation;
        this.currentTranslation = -transformation;
    }
    /**
     * Trigger drag stop
     * If client leaves the page (navigating to another tab) and comes back, stop the dragging.
     * Correct Typescript typing not possible?
     */
    unActiveTab(event) {
        if (event.target.visibilityState === 'visible') {
            this.dragStop(event);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY2Fyb3VzZWwvc3JjL2xpYi9zbGlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsTUFBTSxPQUFPLE1BQU07SUF5QmpCLFlBQ21CLFFBQWtCLEVBQ2xCLFVBQW1CLEVBQ25CLGFBQXFCLEVBQ3JCLGdCQUF3QixFQUN4QixjQUFzQixFQUN0QixTQUFrQixFQUNsQixpQkFBeUIsRUFDekIsaUJBQXlCLEVBQ3pCLFlBQW9CLEVBQ3BCLGVBQXdCLEVBQ3hCLFdBQW9CLEVBQ3BCLFFBQWlCLEVBQzFCLGVBQWdDO1FBWnZCLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsZUFBVSxHQUFWLFVBQVUsQ0FBUztRQUNuQixrQkFBYSxHQUFiLGFBQWEsQ0FBUTtRQUNyQixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQVE7UUFDeEIsbUJBQWMsR0FBZCxjQUFjLENBQVE7UUFDdEIsY0FBUyxHQUFULFNBQVMsQ0FBUztRQUNsQixzQkFBaUIsR0FBakIsaUJBQWlCLENBQVE7UUFDekIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFRO1FBQ3pCLGlCQUFZLEdBQVosWUFBWSxDQUFRO1FBQ3BCLG9CQUFlLEdBQWYsZUFBZSxDQUFTO1FBQ3hCLGdCQUFXLEdBQVgsV0FBVyxDQUFTO1FBQ3BCLGFBQVEsR0FBUixRQUFRLENBQVM7UUFDMUIsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBckMxQyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLGlCQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ2pCLGVBQVUsR0FBRyxDQUFDLENBQUM7UUFDZix1QkFBa0IsR0FBRyxDQUFDLENBQUM7UUFDdkIsd0JBQW1CLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLGNBQVMsR0FBcUIsT0FBTyxDQUFDO1FBQ3RDLFdBQU0sR0FBRyxDQUFDLENBQUM7UUFDWCxjQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsYUFB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RDtnQkFDcEQsY0FBYyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQztnQkFDNUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUN6QixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxnQ0FBZ0MsQ0FDdkQsQ0FBQzthQUNIO1NBQ0Y7UUFFRCxJQUFJLENBQUMsbUJBQW1CLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELG1CQUFtQixDQUFDLGNBQXNCO1FBQ3hDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxhQUFhLElBQUksQ0FBQyxpQkFBaUIsTUFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUUxRyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsZUFBZSxDQUFDLGNBQWMsZUFBZSxDQUFDO1FBRXJGLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLGNBQWMsQ0FBQztRQUMzQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxjQUFjLENBQUM7SUFDNUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxXQUFXLENBQUMsS0FBVTtRQUNwQixJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsZUFBZSxLQUFLLFNBQVMsRUFBRTtZQUM5QyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3RCO0lBQ0gsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2Fyb3VzZWwgfSBmcm9tICcuL2Nhcm91c2VsJztcclxuaW1wb3J0IHsgQ2Fyb3VzZWxTZXJ2aWNlIH0gZnJvbSAnLi9jYXJvdXNlbC5zZXJ2aWNlJztcclxuXHJcbmV4cG9ydCBjbGFzcyBTbGlkZXIge1xyXG4gIGRyYWdnaW5nID0gZmFsc2U7XHJcbiAgY3VycmVudFNsaWRlID0gMDtcclxuICBsYXN0V2luZG93ID0gMDtcclxuICBjdXJyZW50VHJhbnNsYXRpb24gPSAwO1xyXG4gIHByZXZpb3VzVHJhbnNsYXRpb24gPSAwO1xyXG4gIGRpcmVjdGlvbjogJ3JpZ2h0JyB8ICdsZWZ0JyA9ICdyaWdodCc7XHJcbiAgc3RhcnRYID0gMDtcclxuICBwcmV2aW91c1ggPSAwO1xyXG4gIGN1cnJlbnRYID0gMDtcclxuICBwb3NpdGlvbkNoYW5nZSA9IDA7XHJcbiAgcHJldkxpbWl0ID0gMDtcclxuICBuZXh0TGltaXQgPSAwO1xyXG4gIHNsaWRlc0NvbnRhaW5lciE6IEhUTUxEaXZFbGVtZW50O1xyXG4gIGFycmF5T2ZTbGlkZXMhOiBIVE1MRGl2RWxlbWVudFtdO1xyXG4gIHRvdGFsQW1vdW50T2ZTbGlkZXMhOiBudW1iZXI7XHJcbiAgaW5pdGlhbEZ1bGxXaWR0aCA9IDA7XHJcbiAgbGFzdFdpbmRvd1RyYW5zbGF0aW9uID0gMDtcclxuICB0b3RhbFNsaWRlcyA9IDA7XHJcbiAgRE9NTGltaXRSZWFjaGVkID0gZmFsc2U7XHJcbiAgdmlzaWJsZU9mZnNldENhcmROb3RSZXNwb25zaXZlID0gMDtcclxuICBpbnZpc2libGVPZmZzZXRDYXJkTm90UmVzcG9uc2l2ZSA9IDA7XHJcbiAgYWNjdW11bGF0ZWRTbGlkZSA9IDA7XHJcbiAgY3VycmVudENhcm91c2VsSUQgPSAwO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2Fyb3VzZWw6IENhcm91c2VsLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXNwb25zaXZlOiBib29sZWFuLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBzbGlkZVRvU2Nyb2xsOiBudW1iZXIsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IExJTUlUX0FVVE9fU0xJREU6IG51bWJlcixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgc3RyZWNoaW5nTGltaXQ6IG51bWJlcixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXV0b1NsaWRlOiBib29sZWFuLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBhbmltYXRpb25UaW1pbmdGbjogc3RyaW5nLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBhbmltYXRpb25UaW1pbmdNczogbnVtYmVyLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBNQVhfRE9NX1NJWkU6IG51bWJlcixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgZW5hYmxlTW91c2VEcmFnOiBib29sZWFuLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBlbmFibGVUb3VjaDogYm9vbGVhbixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5maW5pdGU6IGJvb2xlYW4sXHJcbiAgICBwcml2YXRlIGNhcm91c2VsU2VydmljZTogQ2Fyb3VzZWxTZXJ2aWNlXHJcbiAgKSB7XHJcbiAgICB0aGlzLmluaXRQcm9wZXJ0aWVzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoKTtcclxuICAgIHRoaXMuYWRkU2xpZGVzVG9SaWdodEF0U3RhcnQoKTtcclxuICB9XHJcblxyXG4gIGluaXRQcm9wZXJ0aWVzKCkge1xyXG4gICAgdGhpcy5zbGlkZXNDb250YWluZXIgPSB0aGlzLmNhcm91c2VsLnNsaWRlc0NvbnRhaW5lcjtcclxuICAgIHRoaXMuYXJyYXlPZlNsaWRlcyA9IHRoaXMuY2Fyb3VzZWwuYXJyYXlPZlNsaWRlcztcclxuXHJcbiAgICB0aGlzLnRvdGFsU2xpZGVzID0gdGhpcy5jYXJvdXNlbC50b3RhbFNsaWRlcztcclxuICAgIHRoaXMudG90YWxBbW91bnRPZlNsaWRlcyA9IHRoaXMudG90YWxTbGlkZXM7XHJcblxyXG4gICAgdGhpcy5uZXh0TGltaXQgPSBNYXRoLmZsb29yKHRoaXMuY2Fyb3VzZWwuc2xpZGVXaWR0aFdpdGhHYXApO1xyXG4gICAgdGhpcy5wcmV2TGltaXQgPSAtdGhpcy5jYXJvdXNlbC5zbGlkZVdpZHRoV2l0aEdhcDtcclxuXHJcbiAgICB0aGlzLmNhcm91c2VsU2VydmljZS5jYXJvdXNlbElEICs9IDE7XHJcbiAgICB0aGlzLmN1cnJlbnRDYXJvdXNlbElEID0gdGhpcy5jYXJvdXNlbFNlcnZpY2UuY2Fyb3VzZWxJRDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBwcm9wZXJ0aWVzIG9mIHRoZSBzbGlkZXJcclxuICAgKiBGaXJlZCBhdCBzdGFydCBhbmQgYXQgcmVzaXppbmcuXHJcbiAgICovXHJcbiAgdXBkYXRlUHJvcGVydGllcygpIHtcclxuICAgIHRoaXMubGFzdFdpbmRvdyA9IHRoaXMuY2Fyb3VzZWwubnVtYmVyRG90cyAtIDE7XHJcblxyXG4gICAgdGhpcy51cGRhdGVOb3RSZXNwb25zaXZlKCk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsRnVsbFdpZHRoID0gdGhpcy50b3RhbFNsaWRlcyAqIHRoaXMuY2Fyb3VzZWwuc2xpZGVXaWR0aFdpdGhHYXA7XHJcblxyXG4gICAgdGhpcy5sYXN0V2luZG93VHJhbnNsYXRpb24gPVxyXG4gICAgICB0aGlzLnNsaWRlc0NvbnRhaW5lci5jbGllbnRXaWR0aCAtXHJcbiAgICAgIHRoaXMuY2Fyb3VzZWwuc2xpZGVUb1Nob3cgKiB0aGlzLmNhcm91c2VsLnNsaWRlV2lkdGhXaXRoR2FwICtcclxuICAgICAgdGhpcy5jYXJvdXNlbC5nYXA7XHJcblxyXG4gICAgdGhpcy5sYXN0V2luZG93VHJhbnNsYXRpb24gKz0gdGhpcy5yZXNwb25zaXZlXHJcbiAgICAgID8gMFxyXG4gICAgICA6IC10aGlzLnZpc2libGVPZmZzZXRDYXJkTm90UmVzcG9uc2l2ZSAtIHRoaXMuY2Fyb3VzZWwuZ2FwO1xyXG5cclxuICAgIHRoaXMuY2Fyb3VzZWwubWF4U2Nyb2xsYWJsZUNvbnRlbnQgPVxyXG4gICAgICB0aGlzLmNhcm91c2VsLndpZHRoU2xpZGVDb250YWluZXIgLVxyXG4gICAgICB0aGlzLmNhcm91c2VsLmNhcm91c2VsV2lkdGggK1xyXG4gICAgICB0aGlzLmNhcm91c2VsLnBhZGRpbmdDYXJvdXNlbDtcclxuXHJcbiAgICBpZiAodGhpcy5jYXJvdXNlbC5udW1iZXJEb3RzID09PSAxKSB7XHJcbiAgICAgIC8vIGlmIGFsbCBzbGlkZXMgdmlzaWJsZSBpbiBvbmUgd2luZG93LCBtYXggc2Nyb2xsYWJsZSBjb250ZW50IGVxdWFscyAwXHJcbiAgICAgIHRoaXMuY2Fyb3VzZWwubWF4U2Nyb2xsYWJsZUNvbnRlbnQgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlTm90UmVzcG9uc2l2ZSgpIHtcclxuICAgIGlmICh0aGlzLnJlc3BvbnNpdmUpIHJldHVybjtcclxuXHJcbiAgICAvLyB2aXNpYmxlIHBhcnQgb2YgdGhlIG9mZnNldCBvZiB0aGUgY2FyZCBpbiBweFxyXG4gICAgdGhpcy52aXNpYmxlT2Zmc2V0Q2FyZE5vdFJlc3BvbnNpdmUgPVxyXG4gICAgICB0aGlzLmNhcm91c2VsLmNhcm91c2VsV2lkdGggLVxyXG4gICAgICB0aGlzLmNhcm91c2VsLnNsaWRlVG9TaG93ICogdGhpcy5jYXJvdXNlbC5zbGlkZVdpZHRoV2l0aEdhcCAtXHJcbiAgICAgIHRoaXMuY2Fyb3VzZWwucGFkZGluZ0Nhcm91c2VsO1xyXG5cclxuICAgIHRoaXMuaW52aXNpYmxlT2Zmc2V0Q2FyZE5vdFJlc3BvbnNpdmUgPVxyXG4gICAgICB0aGlzLmNhcm91c2VsLnNsaWRlV2lkdGggLSB0aGlzLnZpc2libGVPZmZzZXRDYXJkTm90UmVzcG9uc2l2ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBzbGlkZXMgdG8gdGhlIHJpZ2h0IGF0IHN0YXJ0XHJcbiAgICogSWYgb25seSBvbmUgd2luZG93IChudW1iZXIgb2YgZG90cyA9PT0gMSkgYW5kIG5vdCByZXNwb25zaXZlIG1vZGUsIHRoZXJlIGlzIHBvc3NpYmx5IHNwYWNlIGF0IHN0YXJ0IGZvciBzbGlkZXMgdG8gdGhlIHJpZ2h0IChldmVuIHRob3VnaCB0aGlzIGNvbmZpZ3VyYXRpb24gZG9lcyBub3QgbWFrZSBhIGxvdCBvZiBzZW5zZSlcclxuICAgKi9cclxuICBhZGRTbGlkZXNUb1JpZ2h0QXRTdGFydCgpIHtcclxuICAgIGlmICh0aGlzLmNhcm91c2VsLm51bWJlckRvdHMgPiAxIHx8IHRoaXMucmVzcG9uc2l2ZSB8fCAhdGhpcy5pbmZpbml0ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hZGRTbGlkZXNUb1RoZVJpZ2h0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaXJlZCBhdCBkcmFnIHN0YXJ0XHJcbiAgICogSW5zdGFudGlhdGUgcHJvcGVydHkgb2YgdGhlIHN0YXJ0aW5nIGRyYWcgcG9pbnQgb24gdGhlIFggYXhpcy4gVXNlZCB0byBjb21wdXRlIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgKiBEaXNhYmxpbmcgdGhlIHRyYW5zaXRpb24gd2hpbGUgYXBwbHlpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIGJlY2F1c2Ugb2YgdGhlIGF0dGFjaGVkIGFuaW1hdGlvbi5cclxuICAgKi9cclxuICBkcmFnU3RhcnQoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50RXZlbnRJc0Rpc2FibGVkKGV2ZW50KSkgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuc3RhcnRYID1cclxuICAgICAgZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC50b3VjaGVzWzBdLnBhZ2VYO1xyXG5cclxuICAgIC8vIFVzZWZ1bCBmb3IgZGlyZWN0aW9uIGRldGVjdGlvblxyXG4gICAgdGhpcy5wcmV2aW91c1ggPSB0aGlzLnN0YXJ0WDtcclxuICAgIHRoaXMuc2xpZGVzQ29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaXJlZCBhdCBkcmFnIGVuZFxyXG4gICAqIElmIG5vdCBpbmZpbml0ZSBtb2RlIGFuZCBsaW1pdHMgcmVhY2hlZCAoc3RhcnQgb3IgZW5kKSwgcHV0IGJhY2sgdG8gdGhlIGN1cnJlbnQgc2xpZGUuIFVwZGF0ZXMgcHJldmlvdXMgdHJhbnNsYXRpb24uXHJcbiAgICovXHJcbiAgZHJhZ1N0b3AoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50RXZlbnRJc0Rpc2FibGVkKGV2ZW50KSkgcmV0dXJuO1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5wcmV2aW91c1RyYW5zbGF0aW9uID0gdGhpcy5jdXJyZW50VHJhbnNsYXRpb247XHJcblxyXG4gICAgaWYgKHRoaXMuYXV0b1NsaWRlKSB0aGlzLmF1dG9TbGlkZXIoKTtcclxuXHJcbiAgICBpZiAodGhpcy5pbmZpbml0ZSkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGxpbWl0ID1cclxuICAgICAgdGhpcy5jdXJyZW50VHJhbnNsYXRpb24gPiAwIHx8XHJcbiAgICAgIC10aGlzLmN1cnJlbnRUcmFuc2xhdGlvbiA+IHRoaXMubGFzdFdpbmRvd1RyYW5zbGF0aW9uO1xyXG5cclxuICAgIGlmIChsaW1pdCkge1xyXG4gICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1hdGlvbih0aGlzLmN1cnJlbnRTbGlkZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjdXJyZW50RXZlbnRJc0Rpc2FibGVkKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCAmJiAhdGhpcy5lbmFibGVNb3VzZURyYWcpIHx8XHJcbiAgICAgIChldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQgJiYgIXRoaXMuZW5hYmxlVG91Y2gpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBkaXJlY3Rpb25cclxuICAgKiBEbyBub3QgdXBkYXRlIHRoZSBkaXJlY3Rpb24gaW4gY2FzZSBvZiB0aGUgc2FtZSBwcmV2aW91cyBwb3NpdGlvbi5cclxuICAgKi9cclxuICBzZXREaXJlY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5wcmV2aW91c1ggPiB0aGlzLmN1cnJlbnRYKSB7XHJcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ3JpZ2h0JztcclxuICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2aW91c1ggPCB0aGlzLmN1cnJlbnRYKSB7XHJcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2xlZnQnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmlyZWQgYXQgZHJhZ2dpbmdcclxuICAgKiBDb21wdXRlIHRoZSB0cmFuc2xhdGlvbiwgY2hhbmdlIHRoZSBzbGlkZSBudW1iZXIsIHVwZGF0ZSB0aGUgZGlyZWN0aW9uLlxyXG4gICAqL1xyXG4gIGRyYWdNb3ZlKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudEV2ZW50SXNEaXNhYmxlZChldmVudCkpIHJldHVybjtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuY3VycmVudFggPVxyXG4gICAgICBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xyXG5cclxuICAgIHRoaXMuc2V0RGlyZWN0aW9uKCk7XHJcbiAgICB0aGlzLnByZXZpb3VzWCA9IHRoaXMuY3VycmVudFg7XHJcblxyXG4gICAgdGhpcy5wb3NpdGlvbkNoYW5nZSA9IHRoaXMuY3VycmVudFggLSB0aGlzLnN0YXJ0WDtcclxuICAgIHRoaXMuY3VycmVudFRyYW5zbGF0aW9uID0gdGhpcy5wb3NpdGlvbkNoYW5nZSArIHRoaXMucHJldmlvdXNUcmFuc2xhdGlvbjtcclxuXHJcbiAgICAvLyBDdXJyZW50IHRyYW5zbGF0aW9uIGV4Y2VlZGluZyBzdGFydCBvZiBlbmQgbGltaXRzLCBmaW5pdGUgbW9kZVxyXG4gICAgaWYgKCF0aGlzLmluZmluaXRlKSB7XHJcbiAgICAgIGlmICh0aGlzLnN0cmVjaGluZ0VmZmVjdCgpKSByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zbGlkZXNDb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dGhpcy5jdXJyZW50VHJhbnNsYXRpb259cHgsIDAsIDApYDtcclxuXHJcbiAgICB0aGlzLm1vZGlmeUN1cnJlbnRTbGlkZSgpO1xyXG4gIH1cclxuXHJcbiAgc3RyZWNoaW5nRWZmZWN0KCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgKHRoaXMuY3VycmVudFRyYW5zbGF0aW9uID4gdGhpcy5zdHJlY2hpbmdMaW1pdCAmJlxyXG4gICAgICAgIHRoaXMuY3VycmVudFNsaWRlID09PSAwKSB8fFxyXG4gICAgICB0aGlzLmN1cnJlbnRUcmFuc2xhdGlvbiA8XHJcbiAgICAgICAgLXRoaXMuY2Fyb3VzZWwubWF4U2Nyb2xsYWJsZUNvbnRlbnQgLSB0aGlzLnN0cmVjaGluZ0xpbWl0XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW9kaWZ5IGN1cnJlbnQgc2xpZGVcclxuICAgKiBUYWtlIGludG8gYWNjb3VudCBmaW5pdGUgYW5kIGluZmluaXRlIG1vZGUgYW5kIGF1dG8gc2xpZGUuXHJcbiAgICogUmVzcG9uc2libGUgZm9yIGNoYW5naW5nIHNsaWRlIG51bWJlciBhbmQgdXBkYXRpbmcgdGhlIGxpbWl0cy5cclxuICAgKiBJZiBjcmVhdGVTbGlkZXNJbmZpbml0ZU1vZGVJZkxpbWl0c1JlYWNoZWQoKSBkb2Vzbid0IHRha2UgYWN0aW9uLCBzbGlkZSBjaGFuZ2UgYWNjb3JkaW5nIHRvIHByZXZpb3VzIGNvbXB1dGVkIGxpbWl0cy5cclxuICAgKiBJbiBmaW5pdGUgbW9kZSwgaWYgYWxsIHNsaWRlcyB2aXNpYmxlIG9uIG9uZSB3aW5kb3cgb3IgZW5kIG9mIGNhcm91c2VsLCBlYXJseSByZXR1cm4gdG8gbm90IHRyaWdnZXIgUnhqcyBTdWJqZWN0LlxyXG4gICAqL1xyXG4gIG1vZGlmeUN1cnJlbnRTbGlkZSgpIHtcclxuICAgIGlmICh0aGlzLmluZmluaXRlKSB7XHJcbiAgICAgIGlmICh0aGlzLmNyZWF0ZVNsaWRlc0luZmluaXRlTW9kZUlmTGltaXRzKCkpIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICF0aGlzLmluZmluaXRlICYmXHJcbiAgICAgICh0aGlzLmNhcm91c2VsLm51bWJlckRvdHMgPT09IDEgfHxcclxuICAgICAgICAodGhpcy5jdXJyZW50U2xpZGUgPT09IHRoaXMubGFzdFdpbmRvdyAmJiB0aGlzLmRpcmVjdGlvbiA9PT0gJ3JpZ2h0JykpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgtdGhpcy5jdXJyZW50VHJhbnNsYXRpb24gPCB0aGlzLnByZXZMaW1pdCkge1xyXG4gICAgICB0aGlzLmNoYW5nZVNsaWRlTnVtYmVyKC0xKTtcclxuICAgICAgdGhpcy5kZWNyZWFzZUxpbWl0cygpO1xyXG4gICAgfSBlbHNlIGlmICgtdGhpcy5jdXJyZW50VHJhbnNsYXRpb24gPj0gdGhpcy5uZXh0TGltaXQpIHtcclxuICAgICAgdGhpcy5jaGFuZ2VTbGlkZU51bWJlcigxKTtcclxuICAgICAgdGhpcy5pbmNyZWFzZUxpbWl0cygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIHNsaWRlIGNyZWF0aW9uIGluIGluZmluaXRlIG1vZGUgaWYgbGltaXRzIHJlYWNoZWRcclxuICAgKiBNb3VzZSBvciB0b3VjaCBkcmFnLlxyXG4gICAqL1xyXG4gIGNyZWF0ZVNsaWRlc0luZmluaXRlTW9kZUlmTGltaXRzKCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudFRyYW5zbGF0aW9uID4gMCkge1xyXG4gICAgICB0aGlzLmFkZFNsaWRlc1RvVGhlTGVmdCgpO1xyXG4gICAgICB0aGlzLmRlY3JlYXNlTGltaXRzKHRydWUpO1xyXG5cclxuICAgICAgLy8gbm90IGVuYWJsZWQgYXQgc3RhcnRcclxuICAgICAgaWYgKHRoaXMuY3VycmVudFNsaWRlID4gMCkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlU2xpZGVOdW1iZXIoLTEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIGlmICgtdGhpcy5jdXJyZW50VHJhbnNsYXRpb24gPiB0aGlzLmxhc3RXaW5kb3dUcmFuc2xhdGlvbikge1xyXG4gICAgICB0aGlzLmFkZFNsaWRlc1RvVGhlUmlnaHQoKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLkRPTUxpbWl0UmVhY2hlZCkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlUHJldkFuZE5leHRMaW1pdHModGhpcy5hY2N1bXVsYXRlZFNsaWRlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF1dG8gc2xpZGUgY2FyZCBpZiBvcHRpb24gZW5hYmxlZCwgYXBwbGllZCBvbiBib3RoIGRpcmVjdGlvbnMuXHJcbiAgICogUHJldmVudHMgYXV0byBzbGlkZSBvbiBsaW1pdHMgaW4gZmluaXRlIG1vZGUgKGlmIHN0cmVjaGluZyA8IGxpbWl0IGF1dG8gc2xpZGUpLlxyXG4gICAqIElmIG9ubHkgb25lIHNsaWRlIGlzIGRpc3BsYXllZCAoc2xpZGVUb1Nob3cgPT09IDEpLCB0aGUgd2lkdGggb2YgdGhlIHNsaWRlIGNvcnJlc3BvbmRzIHRvIHRoZSB3aW5kb3cncyB3aWR0aCAoYSBkb3QpLiBIZW5jZSwgdGFraW5nIHRoZSBtaW4gYmV0d2VlbiB0aGUgdHdvLlxyXG4gICAqIEluIG5vbiByZXNwb25zaXZlIGFuZCBub24gaW5maW5pdGUsIHRoZXJlIGlzIHBvc3NpYmx5IGFuIG9mZnNldCBvZiB0aGUgY3VycmVudCBsaW1pdC5cclxuICAgKi9cclxuICBhdXRvU2xpZGVyKCkge1xyXG4gICAgaWYgKFxyXG4gICAgICAhdGhpcy5pbmZpbml0ZSAmJlxyXG4gICAgICAodGhpcy5jdXJyZW50VHJhbnNsYXRpb24gPiAwIHx8XHJcbiAgICAgICAgLXRoaXMuY3VycmVudFRyYW5zbGF0aW9uID4gdGhpcy5sYXN0V2luZG93VHJhbnNsYXRpb24pXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlZmVyZW5jZVdpZHRoID0gTWF0aC5taW4oXHJcbiAgICAgIHRoaXMuY2Fyb3VzZWwuc2xpZGVXaWR0aCxcclxuICAgICAgdGhpcy5jYXJvdXNlbC5zbGlkZU1heFdpZHRoIHx8IEluZmluaXR5XHJcbiAgICApO1xyXG4gICAgbGV0IGN1cnJlbnRMaW1pdCA9IHRoaXMucHJldkxpbWl0ICsgdGhpcy5jYXJvdXNlbC5zbGlkZVdpZHRoV2l0aEdhcDtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICF0aGlzLnJlc3BvbnNpdmUgJiZcclxuICAgICAgIXRoaXMuaW5maW5pdGUgJiZcclxuICAgICAgdGhpcy5jdXJyZW50U2xpZGUgPiB0aGlzLmxhc3RXaW5kb3cgLSAxXHJcbiAgICApIHtcclxuICAgICAgY3VycmVudExpbWl0ID0gdGhpcy5sYXN0V2luZG93VHJhbnNsYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHJldmlvdXNUcmFuc2xhdGlvbiBhbHdheXMgYSBuZWdhdGl2ZSBudW1iZXIsIGN1cnJlbnRMaW1pdCBhbHdheXMgcG9zaXRpdmVcclxuICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvbkNoYW5nZSA9IHRoaXMucHJldmlvdXNUcmFuc2xhdGlvbiArIGN1cnJlbnRMaW1pdDtcclxuICAgIGNvbnN0IG1vdmVDb21wYXJlZFRvU2xpZGUgPSAoY3VycmVudFBvc2l0aW9uQ2hhbmdlIC8gcmVmZXJlbmNlV2lkdGgpICogMTAwO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgbW92ZUNvbXBhcmVkVG9TbGlkZSA8IC10aGlzLkxJTUlUX0FVVE9fU0xJREUgfHxcclxuICAgICAgbW92ZUNvbXBhcmVkVG9TbGlkZSA+IHRoaXMuTElNSVRfQVVUT19TTElERVxyXG4gICAgKSB7XHJcbiAgICAgIGlmIChtb3ZlQ29tcGFyZWRUb1NsaWRlID4gdGhpcy5MSU1JVF9BVVRPX1NMSURFKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VTbGlkZU51bWJlcigtMSk7XHJcbiAgICAgICAgdGhpcy5kZWNyZWFzZUxpbWl0cygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlU2xpZGVOdW1iZXIoMSk7XHJcbiAgICAgICAgdGhpcy5pbmNyZWFzZUxpbWl0cygpO1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAtdGhpcy5jdXJyZW50VHJhbnNsYXRpb24gPiB0aGlzLmxhc3RXaW5kb3dUcmFuc2xhdGlvbiAmJlxyXG4gICAgICAgICAgdGhpcy5pbmZpbml0ZVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgdGhpcy5hZGRTbGlkZXNUb1RoZVJpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1hdGlvbih0aGlzLmFjY3VtdWxhdGVkU2xpZGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gcHV0IGJhY2sgdG8gY3VycmVudCBzbGlkZVxyXG4gICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1hdGlvbih0aGlzLmFjY3VtdWxhdGVkU2xpZGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwZW5kIG9yIHByZXBlbmQgbmV3IHNsaWRlcyBhY2NvcmRpbmcgdG8gdGhlIGRpcmVjdGlvblxyXG4gICAqIElmIG5ldyBzbGlkZXMgcHJlcGVuZGVkLCB1cGRhdGUgdGhlIHRyYW5zbGF0aW9uIHRvIHRoZSBjb3JyZWN0IHBsYWNlIChhcHBlbmRpbmcgbmV3IHNsaWRlcyBkbyBub3QgY2hhbmdlIHRoZSB0cmFuc2xhdGlvbikuXHJcbiAgICogTGltaXQgRE9NIGdyb3d0aCBvciB1cGRhdGUgbGFzdCB3aW5kb3cgdHJhbnNsYXRpb24gaWYgYXBwbGljYWJsZS5cclxuICAgKi9cclxuICBhcHBlbmRPclByZXBlbmRORWxlbWVudHMoKSB7XHJcbiAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5hcnJheU9mU2xpZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgY29uc3QgY2xvbmVkRWxlbWVudCA9IHRoaXMuYXJyYXlPZlNsaWRlc1tpXS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5zbGlkZXNDb250YWluZXIucHJlcGVuZChjbG9uZWRFbGVtZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5hY2N1bXVsYXRlZFNsaWRlICs9IHRoaXMudG90YWxTbGlkZXM7XHJcbiAgICAgIHRoaXMucmVzZXRWaWV3TGVmdERpcmVjdGlvbigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFycmF5T2ZTbGlkZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjbG9uZWRFbGVtZW50ID0gdGhpcy5hcnJheU9mU2xpZGVzW2ldLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICB0aGlzLnNsaWRlc0NvbnRhaW5lci5hcHBlbmQoY2xvbmVkRWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy50b3RhbEFtb3VudE9mU2xpZGVzID49IHRoaXMuTUFYX0RPTV9TSVpFICogdGhpcy50b3RhbFNsaWRlcykge1xyXG4gICAgICAvLyBMaW1pdCBET00gZ3Jvd3RoLCBtYXggWCB0aW1lcyBvcmlnaW5hbCBET01cclxuICAgICAgLy8gY29uc29sZS5sb2coJ2RvbSBsaW1pdCByZWFjaGVkJyk7XHJcbiAgICAgIHRoaXMubGltaXRET01Hcm93dGgoKTtcclxuICAgICAgdGhpcy5ET01MaW1pdFJlYWNoZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy50b3RhbEFtb3VudE9mU2xpZGVzICs9IHRoaXMudG90YWxTbGlkZXM7XHJcbiAgICAgIHRoaXMuRE9NTGltaXRSZWFjaGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMudXBkYXRlTGFzdFdpbmRvd1RyYW5zbGF0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaW1pdCBET00gZ3Jvd3RoXHJcbiAgICogUmVzZXQgdGhlIHZpZXcgYWNjb3JkaW5nbHkuXHJcbiAgICovXHJcbiAgbGltaXRET01Hcm93dGgoKSB7XHJcbiAgICBjb25zdCBzbGlkZXMgPSB0aGlzLmNhcm91c2VsLnNlbGVjdFNsaWRlcygpO1xyXG5cclxuICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG90YWxTbGlkZXM7IGkrKykge1xyXG4gICAgICAgIHNsaWRlc1tpXS5yZW1vdmUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5yZXNldFZpZXdSaWdodERpcmVjdGlvbigpO1xyXG4gICAgICB0aGlzLmFjY3VtdWxhdGVkU2xpZGUgLT0gdGhpcy50b3RhbFNsaWRlcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAoXHJcbiAgICAgICAgbGV0IGkgPSBzbGlkZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICBpID4gc2xpZGVzLmxlbmd0aCAtIHRoaXMudG90YWxTbGlkZXMgLSAxO1xyXG4gICAgICAgIGktLVxyXG4gICAgICApIHtcclxuICAgICAgICBzbGlkZXNbaV0ucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSB2aWV3IGluIGEgbW92ZW1lbnQgdG8gdGhlIGxlZnRcclxuICAgKiBOZXcgc2xpZGVzIGFkZGVkIHRvIHRoZSBsZWZ0LCBzbyB0aGUgdmlldyBoYXMgdG8gYmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cclxuICAgKiBJZiB0aGUgY2Fyb3VzZWwgaXMgbW92ZWQgd2l0aCB0aGUgbW91c2UgfCB0b3VjaCBldmVudCAoZHJhZ2dpbmcgaXMgdHJ1ZSksIHRoZSBvZmZzZXQgc2hvdWxkIGJlIGVxdWFsIHRvIGEgZnVsbCBjYXJvdXNlbCB3aWR0aC4gT3RoZXJ3aXNlICh3aXRoIHRoZSBidXR0b25zKSwgdGhlIGNvbXB1dGVkIHRyYW5zbGF0aW9uIHNob3VsZCBiZSB0YWtlbiBpbnRvIGFjY291bnQuXHJcbiAgICogU2lkZSBjb21tZW50OiB0aGUgdmlldyBkb2VzIG5vdCBoYXZlIHRvIGJlIHVwZGF0ZWQgZm9yIHNsaWRlcyBhZGRlZCB0byB0aGUgcmlnaHQsIHNpbmNlIHJlbGF0aXZlIG9yZGVyIGRvZXMgbm90IGNoYW5nZS5cclxuICAgKiBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdHJpZ2dlcnMgcmVmbG93IG9mIHRoZSBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHJlc2V0Vmlld0xlZnREaXJlY3Rpb24oKSB7XHJcbiAgICBjb25zdCB0cmFuc2xhdGlvbiA9XHJcbiAgICAgIE1hdGguYWJzKHRoaXMucHJldmlvdXNUcmFuc2xhdGlvbikgKyB0aGlzLmluaXRpYWxGdWxsV2lkdGg7XHJcbiAgICB0aGlzLnByZXZpb3VzVHJhbnNsYXRpb24gPSAtdHJhbnNsYXRpb247XHJcblxyXG4gICAgdGhpcy5zbGlkZXNDb250YWluZXIuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJztcclxuICAgIHRoaXMuc2xpZGVzQ29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke1xyXG4gICAgICB0aGlzLmRyYWdnaW5nID8gLXRoaXMuaW5pdGlhbEZ1bGxXaWR0aCA6IC10cmFuc2xhdGlvblxyXG4gICAgfXB4LCAwcHgsIDBweClgO1xyXG5cclxuICAgIHRoaXMuc2xpZGVzQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHZpZXcgaW4gYSBtb3ZlbWVudCB0byB0aGUgcmlnaHRcclxuICAgKiBGaXJzdCBzZXQgb2Ygc2xpZGVzIGhhdmUgYmVlbiBkZWxldGVkLCBzbyB0aGUgdHJhbnNsYXRpb24gaGFzIHRvIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXHJcbiAgICogY3VycmVudFRyYW5zbGF0aW9uIGlzIGEgbmVnYXRpdmUgbnVtYmVyIHNvIGl0IHdpbGwgYmUgZGVjcmVhc2VkIGJ5IGEgc2V0IG9mIHNsaWRlcy5cclxuICAgKiBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdHJpZ2dlcnMgcmVmbG93IG9mIHRoZSBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHJlc2V0Vmlld1JpZ2h0RGlyZWN0aW9uKCkge1xyXG4gICAgY29uc3QgdHJhbnNsYXRpb24gPSB0aGlzLmN1cnJlbnRUcmFuc2xhdGlvbiArIHRoaXMuaW5pdGlhbEZ1bGxXaWR0aDtcclxuXHJcbiAgICB0aGlzLnNsaWRlc0NvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xyXG4gICAgdGhpcy5zbGlkZXNDb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRpb259cHgsIDBweCwgMHB4KWA7XHJcbiAgICB0aGlzLnByZXZpb3VzVHJhbnNsYXRpb24gPSB0cmFuc2xhdGlvbiAtIHRoaXMucG9zaXRpb25DaGFuZ2U7XHJcblxyXG4gICAgdGhpcy5zbGlkZXNDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGxhc3Qgd2luZG93IHRyYW5zbGF0aW9uXHJcbiAgICogVXNlZnVsIHRvIGdldCB0aGUgbWF4IHRyYW5zbGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHNsaWRlcy5cclxuICAgKiBJbiBub3QgcmVzcG9uc2l2ZSBtb2RlLCB0aGVyZSBpcyBwb3NzaWJseSBhIG5vdCBmdWxseSBkaXNwbGF5ZWQgY2FyZCAoY2FyZCBvZmZzZXQpLlxyXG4gICAqL1xyXG4gIHVwZGF0ZUxhc3RXaW5kb3dUcmFuc2xhdGlvbigpIHtcclxuICAgIGNvbnN0IHRvdGFsID0gdGhpcy50b3RhbEFtb3VudE9mU2xpZGVzICogdGhpcy5jYXJvdXNlbC5zbGlkZVdpZHRoV2l0aEdhcDtcclxuXHJcbiAgICB0aGlzLmxhc3RXaW5kb3dUcmFuc2xhdGlvbiA9XHJcbiAgICAgIHRvdGFsIC0gdGhpcy5jYXJvdXNlbC5zbGlkZVRvU2hvdyAqIHRoaXMuY2Fyb3VzZWwuc2xpZGVXaWR0aFdpdGhHYXA7XHJcblxyXG4gICAgdGhpcy5sYXN0V2luZG93VHJhbnNsYXRpb24gKz0gdGhpcy5yZXNwb25zaXZlXHJcbiAgICAgID8gMFxyXG4gICAgICA6IC10aGlzLnZpc2libGVPZmZzZXRDYXJkTm90UmVzcG9uc2l2ZSAtIHRoaXMuY2Fyb3VzZWwuZ2FwO1xyXG4gIH1cclxuXHJcbiAgYWRkU2xpZGVzVG9UaGVMZWZ0KCkge1xyXG4gICAgdGhpcy5hcHBlbmRPclByZXBlbmRORWxlbWVudHMoKTtcclxuICB9XHJcblxyXG4gIGFkZFNsaWRlc1RvVGhlUmlnaHQoKSB7XHJcbiAgICB0aGlzLmFwcGVuZE9yUHJlcGVuZE5FbGVtZW50cygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjcmVhc2UgbGltaXQgKG1vdmVtZW50IHRvIHRoZSBsZWZ0KVxyXG4gICAqIEluIGluZmluaXRlIG1vZGUsIHRha2UgZnVsbCB3aWR0aCBvZiBhIHNldCBpZiBvbiB0aGUgZmlyc3Qgc2xpZGUgYXMgbmV3IHNsaWRlcyBhcmUgY3JlYXRlZCB0byB0aGUgbGVmdCAoYSB3aG9sZSBzZXQgb2Zmc2V0KS5cclxuICAgKiBFeGNlcHRpb246IGlmIG5vdCByZXNwb25zaXZlIChjYXJkIG9mZnNldCkgYW5kIGZpbml0ZSBjYXJvdXNlbCwgdGhlIG5leHQgbGltaXQgaXMgYXQgdGhlIG1heGltdW0gKHRoZSBlbmQgb2YgdGhlIGNhcm91c2VsKVxyXG4gICAqL1xyXG4gIGRlY3JlYXNlTGltaXRzKHNsaWRlc0NyZWF0ZWRPblRoZUxlZnQgPSBmYWxzZSkge1xyXG4gICAgbGV0IHRyYW5zbGF0aW9uQ29ycmVjdGlvbkFmdGVyQ2xvbmUgPSB0aGlzLnByZXZMaW1pdDtcclxuXHJcbiAgICBpZiAoc2xpZGVzQ3JlYXRlZE9uVGhlTGVmdCkge1xyXG4gICAgICB0cmFuc2xhdGlvbkNvcnJlY3Rpb25BZnRlckNsb25lID0gdGhpcy5pbml0aWFsRnVsbFdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJldkxpbWl0ID1cclxuICAgICAgdHJhbnNsYXRpb25Db3JyZWN0aW9uQWZ0ZXJDbG9uZSAtIHRoaXMuY2Fyb3VzZWwuc2xpZGVXaWR0aFdpdGhHYXA7XHJcblxyXG4gICAgdGhpcy5uZXh0TGltaXQgPSB0aGlzLnByZXZMaW1pdCArIDIgKiB0aGlzLmNhcm91c2VsLnNsaWRlV2lkdGhXaXRoR2FwO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIXRoaXMucmVzcG9uc2l2ZSAmJlxyXG4gICAgICAhdGhpcy5pbmZpbml0ZSAmJlxyXG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZSA+PSB0aGlzLmxhc3RXaW5kb3cgLSAxXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5uZXh0TGltaXQgPSB0aGlzLmxhc3RXaW5kb3dUcmFuc2xhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnByZXZMaW1pdCA9IE1hdGguZmxvb3IodGhpcy5wcmV2TGltaXQpO1xyXG4gICAgdGhpcy5uZXh0TGltaXQgPSBNYXRoLmZsb29yKHRoaXMubmV4dExpbWl0KTtcclxuXHJcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnByZXZMaW1pdCwgdGhpcy5uZXh0TGltaXQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5jcmVhc2UgbGltaXQgb24gYmFzaXMgb2YgcHJldmlvdXMgY29tcHV0ZWQgbGltaXRzIChtb3ZlbWVudCB0byB0aGUgcmlnaHQpXHJcbiAgICogU2NoZW1hOiB8fCBwcmV2aW91cyB8IGN1cnJlbnQgfHwgbmV4dFxyXG4gICAqIEV4Y2VwdGlvbjogaWYgbm90IHJlc3BvbnNpdmUgKGNhcmQgb2Zmc2V0KSBhbmQgZmluaXRlIGNhcm91c2VsLCB0aGUgbmV4dCBsaW1pdCBpcyBhdCB0aGUgbWF4aW11bSAodGhlIGVuZCBvZiB0aGUgY2Fyb3VzZWwpXHJcbiAgICovXHJcbiAgaW5jcmVhc2VMaW1pdHMoKSB7XHJcbiAgICB0aGlzLm5leHRMaW1pdCArPSBNYXRoLmZsb29yKHRoaXMuY2Fyb3VzZWwuc2xpZGVXaWR0aFdpdGhHYXApO1xyXG4gICAgdGhpcy5wcmV2TGltaXQgPSBNYXRoLmZsb29yKFxyXG4gICAgICB0aGlzLm5leHRMaW1pdCAtIHRoaXMuY2Fyb3VzZWwuc2xpZGVXaWR0aFdpdGhHYXAgKiAyXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIXRoaXMucmVzcG9uc2l2ZSAmJlxyXG4gICAgICAhdGhpcy5pbmZpbml0ZSAmJlxyXG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZSA+PSB0aGlzLmxhc3RXaW5kb3cgLSAxXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5uZXh0TGltaXQgPSB0aGlzLmxhc3RXaW5kb3dUcmFuc2xhdGlvbjtcclxuXHJcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRTbGlkZSA9PT0gdGhpcy5sYXN0V2luZG93KSB7XHJcbiAgICAgICAgLy8gb25seSB1cGRhdGUgcHJldmlvdXMgbGltaXQgaWYgbGFzdCBzbGlkZSByZWFjaGVkXHJcbiAgICAgICAgdGhpcy5wcmV2TGltaXQgPSBNYXRoLmZsb29yKFxyXG4gICAgICAgICAgdGhpcy5uZXh0TGltaXQgLSB0aGlzLmludmlzaWJsZU9mZnNldENhcmROb3RSZXNwb25zaXZlXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucHJldkxpbWl0LCB0aGlzLm5leHRMaW1pdCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGFuZ2UgcHJldiBhbmQgbmV4dCBsaW1pdCBvbiBiYXNpcyBvZiB0aGUgcHJvdmlkZWQgc2xpZGUgbnVtYmVyXHJcbiAgICogUHJldiBhbmQgbmV4dCBsaW1pdCBhcmUgYWx3YXlzIGNhbGN1bGF0ZWQgYXMgdGhlIGZvbGxvd2luZzpcclxuICAgKiB8fCA8PSBwcmV2IHwgY3VycmVudCB8fCA8PSBuZXh0XHJcbiAgICovXHJcbiAgY2hhbmdlUHJldkFuZE5leHRMaW1pdHMoc2xpZGVOdW1iZXI6IG51bWJlcikge1xyXG4gICAgY29uc3QgbGltaXRJblBYID0gc2xpZGVOdW1iZXIgKiB0aGlzLmNhcm91c2VsLnNsaWRlV2lkdGhXaXRoR2FwO1xyXG4gICAgdGhpcy5uZXh0TGltaXQgPSBNYXRoLmZsb29yKGxpbWl0SW5QWCArIHRoaXMuY2Fyb3VzZWwuc2xpZGVXaWR0aFdpdGhHYXApO1xyXG5cclxuICAgIHRoaXMucHJldkxpbWl0ID0gTWF0aC5mbG9vcihcclxuICAgICAgdGhpcy5uZXh0TGltaXQgLSB0aGlzLmNhcm91c2VsLnNsaWRlV2lkdGhXaXRoR2FwICogMlxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnByZXZMaW1pdCwgdGhpcy5uZXh0TGltaXQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJldmlvdXMgYnV0dG9uIG5hdmlnYXRpb25cclxuICAgKi9cclxuICBwcmV2KCkge1xyXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAnbGVmdCc7XHJcbiAgICBpZiAodGhpcy5pbmZpbml0ZSkge1xyXG4gICAgICB0aGlzLmhhbmRsZUJ0bkluZmluaXRlKC10aGlzLnNsaWRlVG9TY3JvbGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2hhbmdlU2xpZGVOdW1iZXIoLXRoaXMuc2xpZGVUb1Njcm9sbCk7XHJcbiAgICB0aGlzLmNoYW5nZVByZXZBbmROZXh0TGltaXRzKHRoaXMuYWNjdW11bGF0ZWRTbGlkZSk7XHJcbiAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1hdGlvbih0aGlzLmFjY3VtdWxhdGVkU2xpZGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTmV4dCBidXR0b24gbmF2aWdhdGlvblxyXG4gICAqL1xyXG4gIG5leHQoKSB7XHJcbiAgICB0aGlzLmRpcmVjdGlvbiA9ICdyaWdodCc7XHJcbiAgICBpZiAodGhpcy5pbmZpbml0ZSkge1xyXG4gICAgICB0aGlzLmhhbmRsZUJ0bkluZmluaXRlKHRoaXMuc2xpZGVUb1Njcm9sbCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jaGFuZ2VTbGlkZU51bWJlcih0aGlzLnNsaWRlVG9TY3JvbGwpO1xyXG4gICAgdGhpcy5jaGFuZ2VQcmV2QW5kTmV4dExpbWl0cyh0aGlzLmFjY3VtdWxhdGVkU2xpZGUpO1xyXG4gICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtYXRpb24odGhpcy5hY2N1bXVsYXRlZFNsaWRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1dHRvbnMgbmF2aWdhdGlvbiBpbiBpbmZpbml0ZSBtb2RlXHJcbiAgICogQ3JlYXRlIG5ldyBzbGlkZSBpZiBsaW1pdHMgcmVhY2hlZCAoc3RhcnQgb3IgZW5kKS4gVXBkYXRlIHNsaWRlLCBsaW1pdHMgYW5kIGFwcGx5IHRyYW5zZm9ybWF0aW9uIGFjY29yZGluZ2x5LlxyXG4gICAqL1xyXG4gIGhhbmRsZUJ0bkluZmluaXRlKHN0ZXA6IG51bWJlcikge1xyXG4gICAgbGV0IGNhcmRPZmZzZXQgPSAwO1xyXG4gICAgY29uc3QgZ29pbmdUbyA9IHRoaXMuYWNjdW11bGF0ZWRTbGlkZSArIHN0ZXA7XHJcblxyXG4gICAgLy8gdGhlcmUgaXMgKHBvc3NpYmx5KSBhIGNhcmQgb2Zmc2V0IGlmIG5vdCByZXNwb25zaXZlXHJcbiAgICBpZiAoIXRoaXMucmVzcG9uc2l2ZSkgY2FyZE9mZnNldCA9IDE7XHJcblxyXG4gICAgaWYgKGdvaW5nVG8gPCAwKSB7XHJcbiAgICAgIHRoaXMuYWRkU2xpZGVzVG9UaGVMZWZ0KCk7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICBnb2luZ1RvICsgdGhpcy5jYXJvdXNlbC5zbGlkZVRvU2hvdyArIGNhcmRPZmZzZXQgPlxyXG4gICAgICB0aGlzLnRvdGFsQW1vdW50T2ZTbGlkZXNcclxuICAgICkge1xyXG4gICAgICB0aGlzLmFkZFNsaWRlc1RvVGhlUmlnaHQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5hdmlnYXRpb24gd2l0aCBidWxsZXQgcG9pbnRzXHJcbiAgICogVXBkYXRlIHZhbHVlcyBhY2NvcmRpbmdseS5cclxuICAgKi9cclxuICBnb1RvKGJ1bGxldDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMuY3VycmVudFNsaWRlIDwgYnVsbGV0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IGJ1bGxldDtcclxuICAgIHRoaXMuY2Fyb3VzZWxTZXJ2aWNlLm9uQ2hhbmdlKHRoaXMuY3VycmVudFNsaWRlLCB0aGlzLmN1cnJlbnRDYXJvdXNlbElEKTtcclxuXHJcbiAgICBpZiAodGhpcy5pbmZpbml0ZSkge1xyXG4gICAgICB0aGlzLm5hdkluZmluaXRlQnVsbGV0cyhidWxsZXQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hY2N1bXVsYXRlZFNsaWRlID0gdGhpcy5jdXJyZW50U2xpZGU7XHJcbiAgICB0aGlzLmNoYW5nZVByZXZBbmROZXh0TGltaXRzKGJ1bGxldCk7XHJcbiAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1hdGlvbihidWxsZXQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVsbGV0cyBuYXZpZ2F0aW9uXHJcbiAgICogQ3JlYXRlIG5ldyBzbGlkZXMgaWYgZXhjZWVkaW5nIGVuZCBvZiBjYXJvdXNlbC5cclxuICAgKi9cclxuICBuYXZJbmZpbml0ZUJ1bGxldHMoYnVsbGV0OiBudW1iZXIpIHtcclxuICAgIGxldCBjYXJkT2Zmc2V0ID0gMDtcclxuICAgIGNvbnN0IHBvc2l0aW9uT2ZDdXJyZW50U2xpZGUgPSB0aGlzLmFjY3VtdWxhdGVkU2xpZGUgJSB0aGlzLnRvdGFsU2xpZGVzO1xyXG4gICAgY29uc3QgZGlmZmVyZW5jZSA9IGJ1bGxldCAtIHBvc2l0aW9uT2ZDdXJyZW50U2xpZGU7XHJcbiAgICB0aGlzLmFjY3VtdWxhdGVkU2xpZGUgKz0gZGlmZmVyZW5jZTtcclxuXHJcbiAgICAvLyB0aGVyZSBpcyAocG9zc2libHkpIGEgY2FyZCBvZmZzZXQgaWYgbm90IHJlc3BvbnNpdmVcclxuICAgIGlmICghdGhpcy5yZXNwb25zaXZlKSBjYXJkT2Zmc2V0ID0gMTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMuYWNjdW11bGF0ZWRTbGlkZSArIHRoaXMuY2Fyb3VzZWwuc2xpZGVUb1Nob3cgKyBjYXJkT2Zmc2V0ID5cclxuICAgICAgdGhpcy50b3RhbEFtb3VudE9mU2xpZGVzXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5hZGRTbGlkZXNUb1RoZVJpZ2h0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtYXRpb24odGhpcy5hY2N1bXVsYXRlZFNsaWRlKTtcclxuICAgIHRoaXMuY2hhbmdlUHJldkFuZE5leHRMaW1pdHModGhpcy5hY2N1bXVsYXRlZFNsaWRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3BvbnNpYmxlIGZvciBjaGFuZ2luZyBzbGlkZSBudW1iZXIgaW4gZmluaXRlIGFuZCBpbmZpbml0ZSBtb2RlXHJcbiAgICogRXhjZXB0aW9uOiBpZiBvbmx5IG9uZSB3aW5kb3cgKG51bWJlckRvdHMgPT09IDEpLCB1cGRhdGUgdGhlIGFjY3VtdWxhdGVkU2xpZGUgdG8gbGV0IHRoZSB0cmFuc2Zvcm1hdGlvbiBvY2N1cnMsIGJ1dCBjdXJyZW50U2xpZGUgc2hvdWxkIHN0YXkgYXQgMC5cclxuICAgKi9cclxuICBjaGFuZ2VTbGlkZU51bWJlcihzdGVwOiBudW1iZXIpIHtcclxuICAgIGlmICh0aGlzLmluZmluaXRlKSB7XHJcbiAgICAgIHRoaXMuaW5maW5pdGVDaGFuZ2VTbGlkZU51bWJlcihzdGVwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZmluaXRlQ2hhbmdlU2xpZGVOdW1iZXIoc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuY2Fyb3VzZWwubnVtYmVyRG90cyA9PT0gMSkge1xyXG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY3VycmVudCA9XHJcbiAgICAgIHRoaXMuY2Fyb3VzZWwubnVtYmVyRG90cyA+IDEgPyB0aGlzLmN1cnJlbnRTbGlkZSA6IHRoaXMuYWNjdW11bGF0ZWRTbGlkZTtcclxuICAgIHRoaXMuY2Fyb3VzZWxTZXJ2aWNlLm9uQ2hhbmdlKGN1cnJlbnQsIHRoaXMuY3VycmVudENhcm91c2VsSUQpO1xyXG4gIH1cclxuXHJcbiAgaW5maW5pdGVDaGFuZ2VTbGlkZU51bWJlcihzdGVwOiBudW1iZXIpIHtcclxuICAgIHRoaXMuYWNjdW11bGF0ZWRTbGlkZSArPSBzdGVwO1xyXG4gICAgdGhpcy5jdXJyZW50U2xpZGUgKz0gc3RlcDtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50U2xpZGUgPiB0aGlzLmxhc3RXaW5kb3cpIHtcclxuICAgICAgY29uc3Qgc3VycGx1cyA9IHRoaXMuY3VycmVudFNsaWRlICUgdGhpcy5sYXN0V2luZG93O1xyXG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IHN1cnBsdXMgLSAxO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRTbGlkZSA8IDApIHtcclxuICAgICAgY29uc3Qgc3VycGx1cyA9IHRoaXMuY3VycmVudFNsaWRlICUgdGhpcy5sYXN0V2luZG93O1xyXG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IHRoaXMudG90YWxTbGlkZXMgKyBzdXJwbHVzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZmluaXRlQ2hhbmdlU2xpZGVOdW1iZXIoc3RlcDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmN1cnJlbnRTbGlkZSArPSBzdGVwO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRTbGlkZSA+IHRoaXMubGFzdFdpbmRvdykge1xyXG4gICAgICB0aGlzLmN1cnJlbnRTbGlkZSA9IHRoaXMubGFzdFdpbmRvdztcclxuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50U2xpZGUgPCAwKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudFNsaWRlID0gMDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmFjY3VtdWxhdGVkU2xpZGUgPSB0aGlzLmN1cnJlbnRTbGlkZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgdHJhbnNmb3JtYXRpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgb24gYmFzaXMgb2YgdGhlIHByb3ZpZGVkIHNsaWRlIG51bWJlclxyXG4gICAqIEV4Y2VwdGlvbjogaWYgbm90IHJlc3BvbnNpdmUgKGNhcmQgb2Zmc2V0KSBhbmQgZmluaXRlIGNhcm91c2VsLCB0aGUgbmV4dCBsaW1pdCBpcyB0aGUgZW5kIG9mIHRoZSBjYXJvdXNlbFxyXG4gICAqL1xyXG4gIGNvbXB1dGVUcmFuc2Zvcm1hdGlvbihzbGlkZTogbnVtYmVyKSB7XHJcbiAgICBsZXQgdHJhbnNmb3JtYXRpb24gPSBzbGlkZSAqIHRoaXMuY2Fyb3VzZWwuc2xpZGVXaWR0aFdpdGhHYXA7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAhdGhpcy5yZXNwb25zaXZlICYmXHJcbiAgICAgICF0aGlzLmluZmluaXRlICYmXHJcbiAgICAgIHNsaWRlID49IHRoaXMubGFzdFdpbmRvdyAtIDEgJiZcclxuICAgICAgdGhpcy5jYXJvdXNlbC5udW1iZXJEb3RzID4gMVxyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMubmV4dExpbWl0ID0gdGhpcy5sYXN0V2luZG93VHJhbnNsYXRpb247XHJcblxyXG4gICAgICBpZiAoc2xpZGUgPT09IHRoaXMubGFzdFdpbmRvdykge1xyXG4gICAgICAgIC8vIGlmIGxhc3Qgd2luZG93LCBnbyB0byBtYXhpbXVtICYgdXBkYXRlIHByZXYgbGltaXRcclxuICAgICAgICB0cmFuc2Zvcm1hdGlvbiA9IHRoaXMubGFzdFdpbmRvd1RyYW5zbGF0aW9uO1xyXG4gICAgICAgIHRoaXMucHJldkxpbWl0ID0gTWF0aC5mbG9vcihcclxuICAgICAgICAgIHRoaXMubmV4dExpbWl0IC0gdGhpcy5pbnZpc2libGVPZmZzZXRDYXJkTm90UmVzcG9uc2l2ZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb24odHJhbnNmb3JtYXRpb24pO1xyXG4gIH1cclxuXHJcbiAgYXBwbHlUcmFuc2Zvcm1hdGlvbih0cmFuc2Zvcm1hdGlvbjogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnNsaWRlc0NvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke3RoaXMuYW5pbWF0aW9uVGltaW5nTXN9bXMgJHt0aGlzLmFuaW1hdGlvblRpbWluZ0ZufWA7XHJcblxyXG4gICAgdGhpcy5zbGlkZXNDb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7LXRyYW5zZm9ybWF0aW9ufXB4LCAwcHgsIDBweClgO1xyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMucHJldmlvdXNUcmFuc2xhdGlvbiA9IC10cmFuc2Zvcm1hdGlvbjtcclxuICAgIHRoaXMuY3VycmVudFRyYW5zbGF0aW9uID0gLXRyYW5zZm9ybWF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlciBkcmFnIHN0b3BcclxuICAgKiBJZiBjbGllbnQgbGVhdmVzIHRoZSBwYWdlIChuYXZpZ2F0aW5nIHRvIGFub3RoZXIgdGFiKSBhbmQgY29tZXMgYmFjaywgc3RvcCB0aGUgZHJhZ2dpbmcuXHJcbiAgICogQ29ycmVjdCBUeXBlc2NyaXB0IHR5cGluZyBub3QgcG9zc2libGU/XHJcbiAgICovXHJcbiAgdW5BY3RpdmVUYWIoZXZlbnQ6IGFueSkge1xyXG4gICAgaWYgKGV2ZW50LnRhcmdldC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xyXG4gICAgICB0aGlzLmRyYWdTdG9wKGV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19